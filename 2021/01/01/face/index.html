<!DOCTYPE html><html lang="zh_CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>面试题 | 野菜</title><meta name="keywords" content="面试题"><meta name="author" content="野菜"><meta name="copyright" content="野菜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="面试题"><meta name="application-name" content="面试题"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="面试题"><meta property="og:url" content="http://example.com/2021/01/01/face/index.html"><meta property="og:site_name" content="野菜"><meta property="og:description" content="[TOC]  HTML 1.  html5有什么优化 2. 如何理解HTML语义化 3. meta标签   CSS 0. css3有什么优化 1. CSS选择器及优先级 2. position 属性的值有哪些及其区别 3. box-sizing属性 4. CSS 盒子模型 5. BFC（块级格式上下"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://api.gumengya.com/Api/FjImg?format=image&amp;_t=4"><meta property="article:author" content="野菜"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://api.gumengya.com/Api/FjImg?format=image&amp;_t=4"><meta name="description" content="[TOC]  HTML 1.  html5有什么优化 2. 如何理解HTML语义化 3. meta标签   CSS 0. css3有什么优化 1. CSS选择器及优先级 2. position 属性的值有哪些及其区别 3. box-sizing属性 4. CSS 盒子模型 5. BFC（块级格式上下"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2021/01/01/face/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://friends.anheyu.com/"},
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 野菜","link":"链接: ","source":"来源: 野菜","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '野菜',
  title: '面试题',
  postAI: '',
  pageFillDescription: 'HTML, 1.  html5有什么优化, 2. 如何理解HTML语义化, 3. meta标签, 4. src 和 href 的区别, CSS, 0. css3有什么优化, 1. CSS选择器及优先级, 2. position 属性的值有哪些及其区别, 3. box-sizing属性, 4. CSS 盒子模型, 5. BFC（块级格式上下文）和IFC(行级格式化上下), 6. 水平垂直居中, 自适应两栏布局, 三栏布局, 7. 用CSS实现三角符号, 8. 常见的布局类型（查）, 9. 浮动（查）, 10. 常见的行内元素和块级元素, 11. pxemremvwvhrpx等单位的特性, 12. 什么是DOM事件流？什么是事件委托(查), 13. 事件冒泡和事件捕捉有什么区别（查）, 14. link和@import, 15. 响应式布局, 16. 元素不可见, 17. css动画属性, transformtranslate(参数1参数2)———位移属性, transform()———-2D缩放, transformrotate()———2D旋转, animation属性, animation-name, animation-duration, animation-timing-function, animation-iteration-count, JS, 0. Object常用的API, 1. 基本数据类型, 2. 数据类型检测, 数据类型转换：, 4. 作用域和作用域链, 5. 什么是闭包, 6. this的指向, 7. new 实现, 9. x3Dx3D 和x3Dx3Dx3D的区别, 10. NaN === NaN返回什么, 11. 手写call、apply、bind（查）, 12. 执行栈和执行上下文, 13. 原型原型链, 14. JS 中的常用的继承方式, 15. 内存泄漏, 16. 垃圾回收机制：, 17. 深拷贝和浅拷贝, 18. js是单线程, 19. promise, 20. async和await, 21. 宏任务和微任务, 22. js执行机制(event loop 事件循环), 24. 防抖和节流, 26. 常用的数组方法（查）, 1. 数组排序, 2. 数组最大值, 1. 冒泡排序, 3. 数组去重, 4. 反转数组, 5. 遍历数组, 1. for of, 2. forEach, 3. some, 4. every, 5. map, 6. filter, 7. find(), 28. bom和dom的区别, 29. JS性能优化的方式, 30. defer 和 async, 31. set和map, 32. for of和for in, 25. js遍历数组的方法（查）, 34. 数组排序, 35. 什么是暂时性死区？, 36. 函数柯里化, 37. null与undefined的区别, 38. new String(a)和String(a), 39. || 和  和！！操作符的返回值, 40.获取安全的undefined, ES6, 1. export 和 export default 有什么区别, 2. var/let/const区别, 3. 箭头函数和普通函数的区别, 4. CommonJS模块和ES6模块, 5. import 和 require 的区别, 6.  Object.defineproperty 和 Proxy, 计算机网络, 一、 跨域问题, 1. CORS, 2. 反向代理, 3. Nginx, 二、HTTP问题, 2.1 GET和POST请求, 2.2 HTTP请求头和响应头, 请求头：, 响应头：, 2.3 HTTP状态码304, 2.4 HTTP 1.0 和 HTTP 1.1, 2.5 HTTP 1.1 和 HTTP 2.0, 2.6 HTTP和HTTPS, 2.7 输入URL后发生了生么, 2.8 请求报文, 2.9 响应报文, 2.10 URL, 2.11 常见的状态码, 三、DNS, 四、网络模型, 五、TCP和UDP, 六、缓存问题, 6.1 本地缓存、cookie、token, 6.2 浏览器缓存, 七、浏览器, 7.1 性能优化, 7.2 渲染机制, 7.3 XSS和CSRF攻击, 7.4 进程和线程, VUE, VUE的优点, SPA页面：, 1. vue双向绑定的原理, Vue单向数据流, 2. Vue监听数组, 3. nextTick, 4. Vue生命周期, 5. computed 、watch、method的区别, 6. Vue性能优化, 7. Vue-router, 1. hasn模式, 2. history模式, 3. 两种模式对比, 8. diff算法, 9. 虚拟DOM, 10. Vue的key（index）, 11. vue组件之间的通信（vuex）, 12. Vue-router有哪几种钩子函数, 13. 为什么组件中 data 是个函数, 14. v-model, 15. v-html和v-text, 17. vue2.0和3.0, 18. vue的$set, 19. v-if和v-for, 20. v-if 和 v-show, 21. 插槽, 22. 自定义事件, 23. 在使用计算属性时函数名与data中的数据名可以同名吗, 24. vue打包后静态资源路径, 25. vue动态设置img, 26. vue 中created和mounted请求数据, 27. 多个后端接口, 28. render>template>el, 29. template编译模板, 30. Vue首页白屏渲染, 31. Vue为什么只有一个根元素, 32. Vue数据发生改变页面会更新吗？如何实现异步更新的, 33. Vue的render函数, 34. MVVMMVC的理解, React, 1. React中key的作用, 2. React的设计思想, 3. JSX是什么和JS的区别, 3. React组建为什么只能有一个根元素为什么不能返回多个元素, 4. React.Fragment, 5. React的生命周期, 6. React 事件机制, 7. React事件处理为什么要手动绑定this, 8. useEffect和useLayoutEffect区别, 9. React性能优化手段, 10. Portal, 11. React组件通信, 11.1 props, 11.2 子传父, 11.3 Context, 11.4 UseReducer, 11.5 Redux, 11.5.1 项目引入, 11.5.2 store 创建, 11.5.3 reducer, 11.5.4 combineReducers, 11.5.5 useSelector, 11.5.6 useDispatch, 11.5.7 redux-thunk, 12. React 和 Vue的区别, 13. SetState是同步还是异步的, 14. React渲染流程, 15. React常用hooks, Webpack, 项目总结, 登陆, 1. 登录验证, 2. 项目的优化有什么优化如何理解语义化标签有什么优化选择器及优先级属性的值有哪些及其区别属性盒子模型块级格式上下文和行级格式化上下水平垂直居中自适应两栏布局三栏布局用实现三角符号常见的布局类型查浮动查常见的行内元素和块级元素等单位的特性什么是事件流什么是事件委托查事件冒泡和事件捕捉有什么区别查和响应式布局元素不可见常用的基本数据类型数据类型检测数据类型转换作用域和作用域链什么是闭包的指向实现和的区别返回什么手写查执行栈和执行上下文原型原型链中的常用的继承方式内存泄漏垃圾回收机制深拷贝和浅拷贝是单线程和宏任务和微任务执行机制事件循环防抖和节流常用的数组方法查冒泡排序数组最大值数组去重反转数组遍历数组和的区别性能优化的方式和和和遍历数组的方法查数组去重数组排序什么是暂时性死区函数柯里化与的区别和和和操作符的返回值和有什么区别区别箭头函数和普通函数的区别计算机网络的二次封装跨域同源策略引起的三次握手状态码和和和网络协议重传从浏览器输入后都经历了什么回流和重绘浏览器渲染机制标签浏览器性能优化登陆实现跨域脚本攻击和跨站请求伪造浏览器缓存进程和线程的结构请求报文和响应报文的结构的优点页面双向绑定的原理单向数据流监听数组生命周期的区别优化方式模式两种模式对比算法虚拟的优缺点的组件之间的通信有哪几种钩子函数为什么组件中是个函数和和的和和插槽自定义事件在使用计算属性时函数名与中的数据名可以同名吗打包后静态资源路径动态设置中和请求数据多个后端接口项目总结登陆登录验证项目的优化有什么优化语义化标签的出现等等等等还有的优化可以给它的设置成等等增加了表单的优化等等增加了增加了播放音频文件的标签如何理解语义化概念合理正确的使用语义化的标签来创建页面结构正确的标签做正确的事为了避免大篇幅的没有语义的标签来构建页面标签优点在没样式的情况下页面整体也会呈现很好的结构效果代码结构清晰易于阅读利于开发和维护方便其他设备解析如屏幕阅读器根据语义渲染网页有利于搜索引擎优化搜索引擎爬虫会根据不同的标签来赋予不同的权重标签为浏览器提供的元信息规定字符编码设置移动端的视区窗口设置头图片和的区别请求资源不同超文本引用用于建立文档与资源的联系常用的有将其所指向的资源下载并应用作用结果不同用于文档与资源之间建立联系请求到的资源替换当前内容浏览器的解析不同将资源解析成文件并行加载请求资源不会阻塞对当前文档的处理会暂停其他资源的处理直到该资源加载解析和执行完毕有什么优化还有动画效果的可以开启加速所以在使用动画的时候尽量要的而不是选择器及优先级带标记的样式属性优先级最高样式表的来源相同时行内样式嵌入样式和外链样式选择器类选择器标签通配符继承浏览器默认属性属性的值有哪些及其区别固定定位元素的位置相对于浏览器窗口是固定位置即使窗口是滚动的它也不会移动定位使元素的位置与文档流无关因此不占据空间定位的元素和其他元素重叠相对定位如果对一个元素进行相对定位它将出现在它所在的位置上然后可以通过设置垂直或水平位置让这个元素相对于它的起点进行移动在使用相对定位时无论是否进行移动元素仍然占据原来的空间因此移动元素会导致它覆盖其它框绝对定位绝对定位的元素的位置相对于最近的已定位父元素如果元素没有已定位的父元素那么它的位置相对于浏览器窗口定位使元素的位置与文档流无关因此不占据空间定位的元素和其他元素重叠粘性定位元素先按照普通文档流定位然后相对于该元素在流中的和最近的块级祖先元素定位而后元素定位表现为在跨越特定阈值前为相对定位之后为固定定位默认定位默认值没有定位元素出现在正常的流中忽略或者声明规定应该从父元素继承属性的值属性规定两个并排的带边框的框语法为宽度和高度分别应用到元素的内容框在宽度和高度之外绘制元素的内边距和边框标准盒子模型为元素设定的宽度和高度决定了元素的边框盒盒子模型继承父元素的值盒子模型盒模型本质上是一个盒子它包括边距边框填充和实际内容中的盒子模型包括盒子模型和标准的盒子模型在标准的盒子模型中指部分的宽度在盒子模型中表示这三个部分的宽度块级格式上下文和行级格式化上下是的缩写即块级格式化上下文是一个独立的渲染区域规定了内部如何布局并且这个区域的子元素不会影响到外面的元素其中比较重要的布局规则有内部垂直放置计算的高度的时候浮动元素也参与计算创建绝对定位元素为或行内块元素即为的值不为应用分属于不同的时可以防止重叠清除内部浮动自适应多栏布局内联格式上下文布局规则内部的盒子会在水平方向一个个地放置的高度由里面最高盒子的高度决定当一行不够放置的时候会自动切换到下一行水平垂直居中利用设置和现将子元素左上角移到父元素中心位置然后再通过来调整子元素的中心点到父元素的中心该方法可以不定宽高利用绝对定位设置和现将子元素左上角移到父元素中心位置然后再通过和以子元素自己的一半宽高进行负值赋值该方法必须定宽高利用自适应两栏布局通过和浮动通过定位通过三栏布局普通三栏通过定位通过浮动实现圣杯布局为左右栏腾出空间用实现三角符号记忆口诀盒子宽高均为零三面边框皆透明常见的布局类型查浮动定位网格布局浮动优点兼容性好缺点浮动会脱离标准文档流定位优点快捷缺点子元素也脱离了标准文档流可用性差布局弹性布局网格布局浮动查设置浮动的图片文字会环绕图片设置浮动的块级元素可以排列在一行设置浮动的行内元素可以设置宽高设置了浮动的元素会脱离文档流如果父级盒子没有设置宽高需要子盒子将她撑起来则会造成高度塌陷也会影响其他元素的排列额外标签法在最后一个浮动标签后新加一个标签给其设置新添加了一个标签会造成不必要的渲染父级添加属性写法方便简单但是如果盒子中有定位元素超出了父级则超出部分会隐藏使用不会新增加标签不回影响元素是最流行的方法伪元素是行内元素正常浏览器清除浮动方法清除浮动的方式号只有执行其他浏览器不执行额外标签法常见的行内元素和块级元素行内元素不能设置宽高多个元素共享一行占满的时候会换行块级元素可以设置宽高一个元素占满一整行可以设置宽高多个元素共享一行占满的时候会换行等单位的特性像素当前元素的字体大小根元素字体大小相对于视窗的宽度视窗宽度是相对于视窗的高度视窗高度是单位翻译为像素值的时候是由元素的字体大小决定的此字体大小会被浏览器中字体大小的设置影响除非显式的在为重写一个单位单位转换为像素值的时候取决于使用它们的元素的的大小但是有因为有继承关系所以比较复杂什么是事件流什么是事件委托查事件流事件发生时会在元素节点之间按照特定的顺序进行传播捕获阶段最顶层节点开始向下传播到目标元素接受的过程目标阶段冒泡阶段目标元素接受然后逐级的向上传播在的第三个参数设为就会在捕获阶段运行默认是冒泡事件委托利用冒泡原理子向父一层层穿透把事件绑定到父元素中以实现事件委托事件冒泡和事件捕捉有什么区别查事件冒泡在中的第三属性设置为默认从下至上儿子至祖宗执行阻止事件冒泡事件捕捉在中的第三属性设置为从上至下祖宗到儿子执行和从属关系是的标签不仅可以加载文件还可以定义连接属性等而是的语法只有导入样式表的作用加载顺序页面被加载时会和同时被加载而引入的将在页面加载完毕后被加载兼容性是才有的语法所以只能在以上才能识别而是标签所以不存在兼容性问题只能控制去改变标签引入的样式而的样式不是可以控制的方式的样式权重高于的权重响应式布局响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局媒体查询可以让我们针对不同的媒体类型定义不同的样式当重置浏览器窗口大小的过程中页面也会根据浏览器的宽度和高度重新渲染页面布局默认情况下我们标签的为我们利用媒体查询设置在不同设备下的字体大小如果通过来实现响应式的布局只需要根据视图容器的大小动态的改变即可元素不可见该元素和他的子元素不会被渲染会让元素从消失渲染的时候不占据任何空间隐藏元素而不更改文档的布局不会让元素从消失渲染的时候任然占据原来的空间元素完全透明不会让元素从消失渲染的时候任然占据原来的空间动画属性参数参数位移属性缩放旋转关键帧名称初始状态属性结束状态属性属性所应用的动画名称关键帧名称必须配合使用动画持续的时间例即为动画的持续时间为动画的运动状态匀速等同于贝塞尔曲线平滑等同于贝塞尔曲线由慢到快等同于贝塞尔曲线由快到慢等同于贝塞尔曲线由慢到快再到慢等同于贝塞尔曲线动画的循坏次数无限循环循环的次数常用的方法创建一个新对象使用现有的对象来提供新创建的对象的方法判断两个值是否为同一个值方法会返回一个布尔值指示对象自身属性中是否具有指定的属性也就是是否有指定的键方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象它将返回目标对象方法返回一个给定对象自身的所有可枚举的数组基本数据类型代表独一无二的值最大的用法是用来定义对象的唯一属性名可以表示任意大小的整数处理转换当中的精度缺失它提供了一种方法来表示大于的整数在最后加定义数据类型检测不同类型优点快速区分基本类型能够区分和原理查找目标对象的原型链精准判断数据类型缺点不能将和区分都返回基本数据类型不能判断写法繁琐不容易记推荐进行封装后使用返回创建实例对象的构造函数的引用如何判断变量是否为数组判断一个数是整数取余类数组转换为数组数据类型转换强制转换和自动转换比较运算算术运算作用域和作用域链作用域规定变量和函数的可适用范围称作用域分为全局作用域和局部作用域全局作用域为程序的最外层作用域一直存在函数作用域只有函数被定义时才会创建包含在父级函数作用域全局作用域内由于作用域的限制每段独立的执行代码块只能访问自己作用域和外层作用域中的变量无法访问到内层作用域的变量作用域链当可执行代码内部访问变量时会先查找本地作用域如果找到目标变量即返回否则会去父级作用域继续查找一直找到全局作用域我们把这种作用域的嵌套机制称为作用域链什么是闭包闭包是指嵌套在一个函数内部中的函数当一个嵌套的子函数引用了外部复函数的变量时就产生了闭包原理当前作用域可以访问上级作用域中的变量作用保护保存当前上下文的某些内容被上下文以外的内容占用当前上下文不被释放则存储的这些私有变量也不会被释放可以供其下级上下文中调取使用相当于把一些值保存起来优点和缺点延长局部变量的生命周期但会导致函数的变量一直保存在内存中过多的闭包可能会导致内存泄漏应用柯里化是把接受多个参数的函数变换成接受一个单一参数最初函数的第一个参数的函数并且返回接受余下的参数而且返回结果的新函数的技术模仿块级作用域函数防抖和节流解决办法在退出函数之前将不使用的局部变量全部删除的指向总是非严格模式下指向一个对象而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的而非函数被声明时的环境在严格模式下指向存在的环境有三种全局执行上下文和函数执行上下文作为对象的方法调用当函数作为对象的方法被调用时指向该对象作为普通函数调用总是指向全局对象在浏览器中通常是对象老王老王构造器调用当运算符调用函数时总是返回一个对象通常也指向这个对象但是如果显式的返回了一个对象那么此次运算结果最终会返回这个对象或调用跟普通的函数调用相比用和可以动态的改变函数的可以理解成在的作用域下调用了函数箭头函数箭头函数不会创建自己的它只会从自己的父类执行上下文继承实现首先创一个新的空对象根据原型链设置空对象的为构造函数的构造函数的指向这个对象执行构造函数的代码为这个新对象添加属性判断函数的返回值类型如果是引用类型就返回这个引用类型的对象实例化对象改变构造函数的指向原型链继承返回这个对象创建一个空对象因为在底层中每个变量是以二进制表示固定长度为位其中第位是符号位再往后位是指数为最后表示的是尾数位而和转为二进制的时候是无限循环小数所以就会进行截取截取以后和就不是他们本身了要比原来大那么一丢丢所以就了解决先给他们放大倍数随后在除以相应倍数和的区别是严格意义上的相等会比较两边的数据类型和值大小是非严格意义上的相等先将转为在比较大小现将转为在进行比较转化为原始类型返回什么返回永远不等于判断是否为用一个函数来判断传入的如果是其他数据类型那么现将它使用转为数字类型在进行判断手写查三者都是改变的指向的方法判断是否是函数和都会调用函数改变函数内部的指向和传递的参数不一样如果不传参数或者第一个参数是或都指向第一个参数是谁就指向谁包括和如果不传参数就是把需要传递给的参数放到一个数组或者类数组中传递进去虽然写的是一个数组但是也相当于给一个个的传递改变函数内部的指向函数不会被调用先判断调用是不是一个函数这里的就是调用的不传参数默认为保存保存参数把伪数组对象转为数组调用函数判断是不是函数默认是保存是否传参判断是否是一个函数保存调用的函数保存参数返回一个函数判断是不是出来的如果是出来的返回一个空对象且使创建出来的实例的指向的且完成函数柯里化如果不是出来的改变指向且完成函数柯里化执行栈和执行上下文执行栈首先栈特点先进后出每次函数调用时就会创建出它的执行上下文然后进行压栈当函数执行完成时它的执行上下文就会被销毁进行弹栈栈底永远是全局环境的执行上下文栈顶永远是正在执行函数的执行上下文只有浏览器关闭的时候全局执行上下文才会弹出执行上下文全局执行上下文只有一个浏览器中的全局对象就是对象指向这个全局对象函数执行上下文每次函数调用时都会新创建一个函数执行上下文原型原型链每个实例对象上都有一个隐式原型属性每个构造函数都有一个显示原型属性两者都指向了构造函数的原型对象上原型对象上的方法和属性能够被实例对象所共享而原型对象上也是一个对象他也有自己的原型就这样一层一层的往上直到的原型对象上的为就这样一层一层的链条形成了原型链这也就是为什么每个对象都能够使用的方法中的常用的继承方式原型继承构造函数继承组合继承寄生组合继承的原型继承会共享引用属性方法一原型继承原型继承把父类的实例作为子类的原型缺点子类的实例共享了父类构造函数的引用属性父类子类继承子类覆盖父类的属性父类的属性子类自己的属性构造函数继承会独享所有属性包括引用属性重点是函数父类子类组合继承利用原型链继承要共享的属性利用构造函数继承要独享的属性实现相对完美的继承方法二组合继承在子函数中运行父函数但是要利用把改变一下再在子函数的里面使的原型中的方法也得到继承最后改变的原型中的缺点调用了两次父类的构造函数造成了不必要的消耗父类方法可以复用优点可传参不共享父类引用属性篮球足球乒乓球寄生组合继承方法三寄生组合继承篮球足球乒乓球方法四的寄生组合继承的语法糖子类只要继承父类可以不写一旦写了则在中的第一句话必须是内存泄漏概念内存泄露是指不再用的内存没有被及时释放出来导致该段内存无法被使用就是内存泄漏全局变量闭包元素的引用定时器原因内存泄漏指我们无法在通过访问某个对象而垃圾回收机制却认为该对象还在被引用因此垃圾回收机制不会释放该对象导致该块内存永远无法使用积少成多系统会越来越卡以至于崩溃解决避免使用全局变量手动删除定时器和移除事件监听垃圾回收机制标记清除法垃圾回收机制获取根节点并标记他们然后访问并标记所有来自它们的引用然后在访问这些对象并标记它们的引用如此递进结束后若发现有没有标记的不可达的进行删除进入执行环境的不能进行删除引用计数法当声明一个变量并赋值时值当该值被取代时为时进行删除深拷贝和浅拷贝浅拷贝创建了一个新对象这个对象有着原始对象属性值的一份精确拷贝如果属性是基本类型则拷贝的就是基本类型的值如果属性是引用类型拷贝的就是内存地址所以如果其中一个对象改变了这个地址就会影响到另一个对象方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象它将返回目标对象方法返回一个新的数组对象这一对象是一个由和不包括决定的原数组的浅拷贝原始数组不会被改变拓展运算符深拷贝拷贝所有的属性并在计算机中开辟出了一块新的内存拷贝前后两个对象互不影响实用工具库提供了许多中的合并根据条件去除某个元素手写循环递归缺点函数丢失时间戳字符串时间错误信息空对象循环引用对象报错中有属性是出来的则会丢弃对应的初始化构造器是单线程因为里面有可视的如果是多线程的话这个线程正在删除节点另一个线程正在编辑节点导致浏览器不知道该听谁的是异步编程的解决方案简单来说就是一个容器里面保存着一个异步操作的结果从语法上说是一个对象可以改变对象获取异步操作的消息共有三个状态执行中成功失败状态只能由或者且一但发生改变便不可二次修改作用他可以解决回调地狱的问题也就是异步深层嵌套的问题基本使用我们可以一个的构造函数接受一个函数并且传入两个参数和分别表示异步操作执行成功的回调和失败的回调实例生成以后可以用方法指定状态和状态的回调函数获取异常信息创建的会在这一组全部解决后在解决也就是说会等待所有的程序都返回结果之后执行后续的程序返回一个新的应用当需要加载的资源较多时如果所有都成功则合成的返回值就是所有子的返回值数组如果有一个失败那么第一个失败的会把自己的理由作为合成的失败理由得到的却是数组中跑的最快的那个当最快的一跑完就立马结束做一些异步操作出错了成功回调失败了通过获取网络图片手写加载图片网上随便找一个图片的地址定义一个异步加载图片的函数一个对象创建一个节点把我们的图片地址给我们新建的节点通过监听节点成功建立当然图片也传进去调用返回整个节点可以用捕捉监听错误可以用捕捉图片加载失败地址为记得把整个对象返回调用异步函数和作用用于申明一个是异步的而用于等待一个异步方法执行完成他可以很好的替代中的函数返回一个对象当函数执行的时候一旦遇到就会先返回等到异步操作完成在接着执行函数体内后面的语句宏任务和微任务宏任务事件微任务微任务比宏任务先执行的是同步的遇到之前是同步的在执行后面的代码返回下面的代码放入微任务并退出执行机制事件循环代码的执行过程中除了依靠函数调用栈来搞定函数的执行顺序外还依靠任务队列来搞定另外一些代码的执行所有的同步任务都在主线程上执行行成一个执行栈除了主线程之外还存在一个任务列队只要异步任务有了运行结果会将这个函数移入但是异步有一个机制就是遇到宏任务先执行宏任务将宏任务放入然后在执行宏任务中的微任务将微任务放入但是两个不同主线程执行完毕后会去微任务中读取进入主线程执行再从宏任务的读取重复上面三步防抖和节流防抖秒后在执行该事件若在秒内被重复触发则重新计时频繁操作点赞和取消点赞搜索联想节流秒内只运行一次若在秒内重复触发只有一次生效鼠标不断点击触发函数防抖是某一段时间内只执行一次而函数节流是间隔时间执行常用的数组方法查李白在数组末尾增加剑仙在数组末尾删除在数组开头删除删除修改诗圣数组转化为字符串产生一个新数组不会改变原数组以隔开合并两个数组产生一个新数组不会改变原数组数组的截取产生一个新数组不会改变原数组数组的翻转产生一个新数组不会改变原数组数组排序产生一个新数组不会改变原数组数组排序数组最大值冒泡排序数组去重因为每次删除都会改变数组的长度所以删了之后要是下标之后再回到原来下标反转数组遍历数组不同于的是循环可以随时退出可以通过跳出本次循环执行下一次循环不会对空数组进行检测不会改变原数组检测数组里的每一个值是否满足条件如果有一个满足就返回否则返回不会对空数组进行检测不会改变原数组检测数组里的每一个值是否满足条件如果有一个不满足就返回否则返回不会对空数组进行检测不会改变原数组按照原始数组元素顺序依次处理返回一个新数组不会对空数组进行检测不会改变原数组对数组进行渲染返回符合条件的数组不会对空数组进行检测不会改变原数组找到符合条件的第一项没有找到返回常用的字符串方法查字符串的长度通过下标获取某个字符我是一个字符串截取字符串返回字符串第一次出现的位置没有出现过返回个和的区别只能匹配字符串可以匹配正则和字符串替换字符串我的分割字符串转化为数组表单里面比较重要的的我的字符判断字符串是否有某个字符我多一嘴数组也是一样的方法和的区别就是包含窗口浏览器浏览器屏幕访问历史地址等浏览器相关的东西是包含的是相关的都在里面性能优化的方式垃圾回收防抖节流分批加载加载个节点事件委托的使用标签中的和的基本原理是广泛采用各种缓存服务器将这些缓存服务器分布到用户访问相对集中的地区或网络中在用户访问网站时利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上由缓存服务器直接响应用户请求和浏览器是同步加载脚本即渲染引擎遇到标签就会停下来等到执行完脚本再继续向下渲染如果是外部脚本还必须加入脚本下载的时间如果脚本体积很大下载和执行的时间就会很长因此造成浏览器堵塞用户会感觉到浏览器卡死了没有任何响应这显然是很不好的体验所以浏览器允许脚本异步加载下面就是两种异步加载的语法然后是和他们两个是异步加载代码的渲染引擎遇到这一行命令就会开始下载外部脚本但不会等它下载和执行而是直接执行后面的命令与的区别是要等到整个页面在内存中正常渲染结束结构完全生成以及其他脚本执行完成才会执行一旦下载完渲染引擎就会中断渲染执行这个脚本以后再继续渲染一句话是渲染完再执行是下载完就执行另外如果有多个脚本会按照它们在页面出现的顺序加载而多个脚本是不能保证加载顺序的和提供了新的数据结构它类似于数组但是成员的值都是唯一的没有重复的值通过方法向结构加入成员也可以利用进行数组去重去除数组的重复成员提供了数据结构它类似于对象也是键值对的集合但是键的范围不限于字符串各种类型的值包括对象都可以当作键用作数据存储和遍历数组遍历对象遍历对象的或者数组的下标到原型链查找遍历新增加的属性的值所以不能用于遍历数组遍历数组的方法查循环也是最常见的当前元素必须下标可选数组可选没有返回值当前元素必须下标可选数组可选有返回值一会改变原数组过滤筛选对数组中的每一项运行给定函数返回该函数会返回的想项组成的新数组指数组后返回过滤后的新数组与方法不同的是方法的函数需要返回等于值如果为则通过否则不通过不可以原数组买笔买笔记本练字我是谁我在哪我是谁我在哪数组去重循环嵌套利用去重如果第一个等于第二个方法删除第二个建新数组利用去重一个新的数组遍历当前数组如果临时数组里没有当前数组的当前值则把当前值到新数组里面去重数组排序冒泡排序冒泡排序排序排序选择排序选择排序反转字符串什么是暂时性死区暂时性死区是指当进入一个作用域我去使用一个变量名而这个变量名已经存在了但是是不可获取的就会报错造成暂时性死区问题比如一个作用域下面使用了定义了但是在定义之前就使用了就会报错函数柯里化函数柯里化是指将多变量函数拆解为单变量的多个函数的依次调用可以从高元函数动态地生成批量的低元的函数简单讲就是利用函数执行可以形成一个不销毁的私有作用域把预先处理的内容都存在这个不销毁的作用域里面并且返回一个函数以后要执行的就是这个函数常规的函数后与的区别表示个对象可以是代表是个空对象本身也是对象用作函数的参数表示该函数的参数不是对象用作对象原型链的终点表示不存在是动态类型语成员除了表示存在的空值外还有可能根本就不存在因为存不存在只在运期才知道这就是的意义所在函数没有返回值时默认返回变量已声明没有赋值时为对象中没有赋值的属性该属性的值为调用函数时应该提供的参数没有提供该参数等于和返回的是引用类型在堆内进行存储返回值是字符串对象返回类型是基本类型在栈内存储返回的是字符串和和操作符的返回值两者都会对第一个操作数执行条件判断如果其不是布尔值就先强制转换为布尔类型然后在执行条件判断对于来说如果条件判断结果为就返回第一个操作数的值如果为就返回第二个操作数的值则相反如果条件判断结果为就返回第二个操作数的值如果为就返回第一个操作数的值运算符可以将右侧的值强制转换为布尔值这也是将值转化为布尔值的方法之一获取安全的因为是一个标识符所以可以被当做变量来使用和赋值但是这样会影响的正常判断使用来获得新增类型表示独一无二的值用来定义独一无二的对象属性名都是用来声明变量不可重复声明具有块级作用域存在暂时性死区也就是不存在变量提升一般用于声明常量解构赋值可以将属性值从对象数组中取出赋值给其他变量这种语法是规范引入了一种新语法可以更轻松地从数组和对象中获取值模板字符串比如在处理嵌入表达式多行字符串字符串中插入变量字符串格式化等方面的应用扩展运算符数组对象对象中的扩展运算符用于取出参数对象中的所有可遍历属性拷贝到当前对象之中可以将数组转换为参数序列箭头函数和数据结构提供了新的数据结构它类似于数组但是成员的值都是唯一的没有重复的值通过方法向结构加入成员也可以利用进行数组去重去除数组的重复成员提供了数据结构它类似于对象也是键值对的集合但是键的范围不限于字符串各种类型的值包括对象都可以当作键用作数据存储函数语法和有什么区别是命名导出每个模块可以命名导出多个是默认导出每个模块只能默认导出一个使用导出的使用来导入使用导出的使用来导入两者可以同时存在区别定义的是变量定义的是常量存在变量提升不存在变量提升存在块级作用域声明的常量基本数据类型无法被修改对象或者数组的可以修改内部的属性值可以重复声明在同一个块级作用域中重复声明会报语法错误浏览器的全局对象是的全局对象是声明的变量为全局变量并且会将改变量添加为全局对象的属性但是和不会在使用命令声明变量之前该变量都是不可用的在这语法上称为暂时性死区使用不会存在暂时性死区在变量声明时可以不用设置初始值而声明变量必须设置初始值箭头函数和普通函数的区别箭头函数没有自己的他会从自己的作用域链的上一层继承因此无法使用进行绑定值箭头函数没有对象如果要用可以用参数代替不可以使用命令因此箭头函数不能用作函数不可以使用命令因为没有自己的以及属性模块和模块是对模块的浅拷贝是对模块的引用即只存不读不能改变值指针指向不能变共同点和都可以对引的对象进赋值即对对象内部属性的值进改变和的区别遵循规范是异步模块加载机制是的一个语法标准如果要兼容的话必须转化成调用时间是运行时调用所以理论上可以运用在代码的任何地方是编译时调用所以必须放在文件开头本质是赋值过程后面的内容是什么的结果就是什么比如对象数字字符串函数等然后再把的结果赋值给某个变量它相当于的传送门是解构过程和是实现响应式的原理参数劫持对象对象属性属性值属性值是否可以被修改默认为不可以是否可以被删除是否可以枚举访问属性时会调用该方法返回值就是的值修改的值得时候会调用该方法多个数据劫持返回对象的所有的属性返回对象的所有的属性值试图更新缺陷无法检测对象属性的新增和删除若想实现则通过或者无法检测到数组的变化是实现响应式的原理代理对象目标对象获取对象属性设置对象属性触发捕获器优点代理整个对象而非对象属性可以监听数组的变化计算机网络一跨域问题概述浏览器基于安全因素的考虑是不允许进行跨域请求的如果发生跨域请求就会发生一下类似的错误跨域原因协议域名端口号解决解决方案有很多种比如前端开发时进行反向代理使用后端设置配置反向代理等等概述跨域资源共享是一种机制当一个资源访问到另一个资源时资源就会发起一个跨域的请求需要浏览器和服务器同时支持处理表示允许哪些网站访问上线后应该直接指定而不应该和客户端对应必须设置以后才能接收反向代理中配置服务器地址本地会虚拟一个服务端接受你的请求并代你发送该请求代理某些服务时用在目录下创建文件下载依赖二问题原理协议采用了请求响应模型客户端向服务器发送一个请求报文请求报文包含请求的方法协议版本请求头部和请求数据服务器以一个状态行作为响应响应的内容包括协议的版本成功或者错误代码服务器信息响应头部和响应数据步骤客户端连接到服务器发送请求服务器接受请求并返回响应释放连接连接客户端浏览器解析内容和请求应用场景请求用于对服务器资源不会产生影响的场景而请求一般用于对服务器资源会产生影响的场景是否缓存浏览器一般会对请求进行缓存但很少对请求进行缓存请求参数请求使用进行传递参数的后面拼接参数请求中的实体报文部分一般为服务器发送的数据安全性因为请求的参数是拼接在后面的所以安全性较差因为请求的会被保留在历史记录中而请求安全性较好请求长度浏览器对有长度限制因此会影响请求发送数据的长度而请求并没有长度限制刷新请求支持刷新和后退而请求每次刷新都会重新发送参数类型请求的参数传递支持更多的数据类型请求头和响应头请求头浏览器能够处理的内容类型浏览器能够显示的字符集浏览器能够处理的压缩编码浏览器当前设置的语言浏览器与服务器之间连接的类型当前页面设置的任何发出请求的页面所在的域发出请求的页面的浏览器的用户代理字符串响应头表示消息发送的时间时间的描述格式由定义服务器名称浏览器与服务器之间连接的类型控制缓存表示后面的文档属于什么类型状态码概述客户端有缓存情况下的服务端的一种响应客户端性能优化的一种方式过多的状态码可能会导致网站快照停止收录减少权重下降和连接方面默认使用非持久连接而默认使用持久连接通过使用持久连接来使多个请求复用同一个连接一次来避免使用非持久连接时每件需要建立链接的时延资源请求中会存在一些浪费宽带的现象例如客户端只是需要某个对象的一部分而服务器却将整个对象送过来了并且不支持断点续传功能则在请求头引入头域他允许只请资源的某个部分即返回码是缓存方面主要使用了里的来做为缓存判断的标准则引入了更多的缓存控制策略例如等更多可供选择的缓存头来控制缓存策略新增加了字段用来指定服务器的域名中并没有传递主机名新增加了很多的请求方法和二进制协议中的豹纹的头信息必须是文本数据体可以是文本也可以是二进制则是一个彻底的二进制协议头信息和数据题都是二进制多路复用实现了多路复用任然复用连接但是在一个连接里客户端和服务器都可以同时发送多喝请求或者回应而且不用按照顺序一一发送数据流使用了数据流的概念因为的数据包是不按顺序发送的同一个链接里面连续的数据包可能属于不同的请求因此必须对数据包做标记指出他属于那个请求将每个请求或回应的所有数据包成为一个数据流每个数据流都有一个独一无二的编号头信息压缩实现了头信息压缩由于协议不带状态每次请求都必须附上所有信息所以请求的很多字段都是重复的比如和一模一样的内容每次请求都必须附带这会浪费很多带宽也影响速度对这一点做了优化引入了头信息压缩机制一方面头信息使用或压缩后再发送另一方面客户端和服务器同时维护一张头信息表所有字段都会存入这个表生成一个索引号以后就不发送同样字段了只发送索引号这样就能提高速度了服务器推送允许服务器未经请求主动向客户端发送资源这叫做服务器推送使用服务器推送提前给客户端推送必要的资源这样就可以相对减少一些延迟时间这里需要注意的是下服务器主动推送的是静态资源和协议需要证书费用较高协议不需要是超文本传输协议信息是明文传输的则是具有安全性的加密传输协议使用不同的连接方式端口也不同协议端口是协议端口是协议连接很简单是无状态的协议是由和协议构建的可进行加密传输身份认证的网络协议比更加安全输入后发生了生么解析首先会对进行解析分析所需要使用的传输协议和请求的资源的路径如果输入的中的协议或者主机名不合法将会把地址栏中输入的内容传递给搜索引擎如果没有问题浏览器会检查中是否出现了非法字符如果存在非法字符则对非法字符进行转义后再进行下一过程缓存判断浏览器会判断所请求的资源是否在缓存里如果请求的资源在缓存里并且没有失效那么就直接使用否则向服务器发起新的请求解析下一步首先需要获取的是输入的中的域名的地址首先会判断本地是否有该域名的地址的缓存如果有则使用如果没有则向本地服务器发起请求本地服务器也会先检查是否存在缓存如果没有就会先向根域名服务器发起请求获得负责的顶级域名服务器的地址后再向顶级域名服务器请求然后获得负责的权威域名服务器的地址后再向权威域名服务器发起请求最终获得域名的地址后本地服务器再将这个地址返回给请求的用户用户向本地服务器发起请求属于递归请求本地服务器向各级域名服务器发起请求属于迭代请求获取地址当浏览器得到地址后数据传输还需要知道目的主机地址因为应用层下发数据给传输层协议会指定源端口号和目的端口号然后下发给网络层网络层会将本机地址作为源地址获取的地址作为目的地址然后将下发给数据链路层数据链路层的发送需要加入通信双方的地址本机的地址作为源地址目的地址需要分情况处理通过将地址与本机的子网掩码相与可以判断是否与请求主机在同一个子网里如果在同一个子网里可以使用协议获取到目的主机的地址如果不在一个子网里那么请求应该转发给网关由它代为转发此时同样可以通过协议来获取网关的地址此时目的主机的地址应该为网关的地址三次握手下面是建立连接的三次握手的过程首先客户端向服务器发送一个连接请求报文段和一个随机序号服务端接收到请求后向服务器端发送一个报文段确认连接请求并且也向客户端发送一个随机序号客户端接收服务器的确认应答后进入连接建立的状态同时向服务器也发送一个确认报文段服务器端接收到确认后也进入连接建立状态此时双方的连接就建立起来了握手如果使用的是协议在通信前还存在的一个四次握手的过程首先由客户端向服务器端发送使用的协议的版本号一个随机数和可以使用的加密方法服务器端收到后确认加密的方法也向客户端发送一个随机数和自己的数字证书客户端收到后首先检查数字证书是否有效如果有效则再生成一个随机数并使用证书中的公钥对随机数加密然后发送给服务器端并且还会提供一个前面所有内容的值供服务器端检验服务器端接收后使用自己的私钥对数据解密同时向客户端发送一个前面所有内容的值供客户端检验这个时候双方都有了三个随机数按照之前所约定的加密方法使用这三个随机数生成一把秘钥以后双方通信前就使用这个秘钥对数据进行加密后再传输返回数据当页面请求发送到服务器端后服务器端会返回一个文件作为响应浏览器接收到响应后开始对文件进行解析开始页面的渲染过程页面渲染浏览器首先会根据文件构建树根据解析到的文件构建树如果遇到标签则判端是否含有或者属性要不然的加载和执行会造成页面的渲染的阻塞当树和树建立好后根据它们来构建渲染树渲染树构建好后会根据渲染树来进行布局布局完成后最后使用浏览器的接口对页面进行绘制这个时候整个页面就显示出来了四次挥手最后一步是断开连接的四次挥手过程若客户端认为数据发送完成则它需要向服务端发送连接释放请求服务端收到连接释放请求后会告诉应用层要释放链接然后会发送包并进入状态此时表明客户端到服务端的连接已经释放不再接收客户端发的数据了但是因为连接是双向的所以服务端仍旧可以发送数据给客户端服务端如果此时还有没发完的数据会继续发送完毕后会向客户端发送连接释放请求然后服务端便进入状态客户端收到释放请求后向服务端发送确认应答此时客户端进入状态该状态会持续最大段生存期指报文段在网络中生存的时间超时会被抛弃时间若该时间段内没有服务端的重发请求的话就进入状态当服务端收到确认应答后也便进入状态请求报文请求行请求法字段字段协议版本字段它们空格分隔例如请求头部请求头部由关键字值对组成每对关键字和值英冒号分割产请求的浏览器类型客户端可识别的内容类型列表请求的主机名允许多个域名同处个地址即虚拟主机空行请求体等请求携带的数据响应报文响应行由网络协议版本状态码和状态码的原因短语组成例如响应头响应部首组成空行响应体服务器响应的数据协议访问服务器获取资源时使用的协议域名资源服务器主机名或地址端口资源服务器监听的端口不同的有不同的默认端口使用作为默认端口路径服务器上的资源路径路径与服务器和有关文件名打开的文件名称参数提供给服务器上的值锚点打开用户页面时滚动到该锚点位置常见的状态码开头的表示成功一般见到的就是开头的表示重定向永久重定向临时重定向表示可以在缓存中取数据协商缓存开头表示客户端错误跨域请求资源不存在开头表示服务端错误三概述是域名系统的缩写提供的是一种主机名到地址的转换服务就是我们常说的域名系统作用将域名解析为地址客户端向服务器服务器有自己的地址发送域名查询请求服务器告知客户机服务器的地址解析过程浏览器缓存首先在浏览器缓存中查找对应的地址如果查到直接返回若找不到就继续下一步本地服务器将请求发送给本地服务器在本地域名服务器缓存中查询如果查找到就直接将查找结果返回若找不到继续下一步根域名服务器本地服务器向根域名服务器发送请求根域名服务器会返回一个所查询域的顶级域名服务器地址顶级域名服务器本地服务器向顶级域名服务器发送请求接受请求的服务器查询自己的缓存如果有记录就返回查询结果如果没有就返回相关的下一级的权威域名服务器的地址权威域名服务器本地服务器向权威域名服务器发送请求域名服务器返回对应的结果本地服务器将返回的结果保存在缓存中便于下次使用本地服务器将返回结果返回给浏览器用户向本地服务器发起请求属于递归请求本地服务器向各级域名服务器发起请求属于迭代请求比如要查询的地址首先会在浏览器的缓存中查找是否有该域名的缓存如果不存在就将请求发送到本地的服务器中本地服务器会判断是否存在该域名的缓存如果不存在则向根域名服务器发送一个请求根域名服务器返回负责的顶级域名服务器的地址的列表然后本地服务器再向其中一个负责的顶级域名服务器发送一个请求负责的顶级域名服务器返回负责的权威域名服务器的地址列表然后本地服务器再向其中一个权威域名服务器发送一个请求最后权威域名服务器返回一个对应的主机名的地址列表四网络模型应用层为应用程序提供服务表示层数据格式转化数据加密会话层建立管理和维护会话传输层建立管理和维护端到端的连接网络层选址及路由选择数据链路层提供介质访问和链路管理物理层物理层五和是否连接无连接面向连接是否可靠不可靠传输不使用流量控制和拥塞控制可靠传输数据顺序和正确性使用流量控制和拥塞控制连接对象个数支持一对一一对多多对一和多对多交互通信只能是一对一通信传输方式面向报文面向字节流首部开销首部开销小仅字节首部最小字节最大字节使用场景适用于实时应用例如视频会议直播适用于要求可靠传输的应用例如文件传输重传机制在发送一个数据之后就开启一个定时器若是在这个时间内没有收到发送数据的确认报文则对该报文进行重传在达到一定次数还没有成功时放弃并发送一个复位信号三次握手第一次握手客户端向服务端发送连接请求报文段该报文段中包含自身的数据通讯初始序号请求发送后客户端便进入状态这样服务端就能得出结论客户端的发送能力服务端的接收能力是正常的第二次握手服务端收到连接请求报文段后如果同意连接则会发送一个应答该应答中也会包含自身的数据通讯初始序号发送完成后便进入状态这样客户端就能得出结论服务端的接收发送能力客户端的接收发送能力是正常的不过此时服务器并不能确认客户端的接收能力是否正常第三次握手当客户端收到连接同意的应答后还要向服务端发送一个确认报文客户端发完这个报文段后便进入状态服务端收到这个应答后也进入状态此时连接建立成功这样服务端就能得出结论客户端的接收发送能力正常服务器自己的发送接收能力也正常三次握手原因客户端共发出了两个连接请求报文段其中第一个丢失第二个到达了服务端但是第一个丢失的报文段只是在某些网络结点长时间滞留了延误到连接释放以后的某个时间才到达服务端此时服务端误认为客户端又发出一次新的连接请求于是就向客户端发出确认报文段同意建立连接不采用三次握手只要服务端发出确认就建立新的连接了此时客户端忽略服务端发来的确认也不发送数据则服务端一致等待客户端发送数据浪费资源四次挥手第一次挥手若客户端认为数据发送完成则它需要向服务端发送连接释放请求第二次挥手服务端收到连接释放请求后会告诉应用层要释放链接然后会发送包并进入状态此时表明客户端到服务端的连接已经释放不再接收客户端发的数据了但是因为连接是双向的所以服务端仍旧可以发送数据给客户端第三次挥手服务端如果此时还有没发完的数据会继续发送完毕后会向客户端发送连接释放请求然后服务端便进入状态第四次挥手客户端收到释放请求后向服务端发送确认应答此时客户端进入状态该状态会持续最大段生存期指报文段在网络中生存的时间超时会被抛弃时间若该时间段内没有服务端的重发请求的话就进入状态当服务端收到确认应答后也便进入状态六缓存问题本地缓存网站为了标识用户身份而储存在客户端的数据不安全考虑服务器性能适用每次求情都会携带和不会自动的把数据发给服务器只会在本地保存一般是用来存储用户会话所需的配置和信息保存在服务端安全登录信息保存其他信息如果需要保留可以放在中存储大小大小一般不能超过而比大得多可以达到有期事件关闭浏览器后数据依然保留除非手动清除否则一直在关闭浏览器或者标签后即失效一般由设置值及过期时间的生命周期是间隔的浏览器缓存浏览器对之前请求过的文件进行缓存以便下一次访问时重复使用节省带宽提高访问速度降低服务器压力强缓存浏览器不会像服务器发送任何请求直接从本地缓存中读取文件并返回强制缓存的情况主要有三种暂不分析协商缓存过程如下不存在该缓存结果和缓存标识强制缓存失效则直接向服务器发起请求跟第一次发起请求一致存在该缓存结果和缓存标识但该结果已失效强制缓存失效则使用协商缓存存在该缓存结果和缓存标识且该结果尚未失效强制缓存生效直接返回该结果当浏览器向服务器发起请求时服务器会将缓存规则放入响应报文的头中和请求结果一起返回给浏览器控制强制缓存的字段分别是和其中优先级比高协商缓存协商缓存就是强制缓存失效后浏览器携带缓存标识向服务器发起请求由服务器根据缓存标识决定是否使用本地缓存的过程主要有以下两种情况协商缓存生效返回协商缓存失效返回和请求结果结果七浏览器性能优化减少请求次数对和打包资源合并适用雪碧图把请求的合并成一张图片给资源做缓存图片按需加载懒加载减少打包体积异步加载文件开启打包路由懒加载图片懒加载预渲染和服务端渲染组件的按需加载渲染机制被解析器解析成树则被解析器解析成树结合树和树生成一棵渲染树根据生成的渲染树进行回流得到节点的几何信息位置大小重绘根据渲染树以及回流得到的几何信息得到节点的绝对像素像素背景色外观等将像素发送给展示在页面上回流重排当的变化影响了元素位置和尺寸大小浏览器需要重新计算元素的几何属性页面第一次加载时进行一次回流当元素的发生改变的时候会发生回流使节点增减或移动读写时浏览器为了获取这些值会进行回流操作使用的时候重绘当改变元素时只是改变了它的外观比如背景颜色等而没有影响到它的布局这个时候会发生重绘回流重排必将引起重绘重绘不一定会引起回流重排如何避免或减少避免逐次改变样式样式统一批量修改离线处理减少回流重绘次数使用在之外建立一个子树属性控制其脱离文档流硬件加速加速和攻击不需要你做任何的登录认证它会通过合法的操作比如在中输入在评论框中输入向你的页面注入脚本可能是代码块等跨域脚本攻击防御编码对用户输入的数据进行编码把字符转换成转义字符的作用是将等一些字符进行转化使得浏览器在最终输出结果上是一样的过滤移除用户输入的和事件相关的属性在未退出网站的前提下访问使用的去访问服务器跨站请求伪造防御使用验证码或者验证每次提交表单时需要带上伪造者访问不到如果不合法服务器拒绝请求通过来判断是否为非法用户给设置属性来限制第三方里面有三个值进程和线程进程是程序的一次执行他占有一片独有的内存空间可以通过任务管理器查看线程是进程内的一个独立执行单元是程序执行的一个完整的流程是的最小的调度单元联系一个线程只能属于一个进程而一个进程可以有多个线程但至少有一个线程资源分配给进程同一进程的所有线程共享该进程的所有资源处理机分给线程即真正在处理机上运行的是线程的优点简单易学轻量级框架渐进式引入双向数据绑定组件化开发结构数据视图分离页面仅在页面初始化时加载相应的一但页面加载完成不会因为用户的操作而进行页面的重新加载或跳转取而代之的是利用路由机制实现内容的变化与用户的交互避免也免得重新加载优点用户体验好避免了不必要的跳转和重新渲染相对对服务器压力小前后端职责分离架构清晰缺点初次加载时耗时多前进后退路由管理难度较大双向绑定的原理是采用数据劫持配合发布者订阅者的模式的方式通过来劫持各个属性的和在数据发生变动时发布消息给订阅者触发相应的监听回调具体为需要的数据对象进行遍历并对其和子属性添加和负责管理数据的依赖列表解析模板指令生成指令对象每个指令对象绑定一个对象会触发收集到仓库中然后数据更新时就会触发这时候相应的对其再次求值如果值确实发生变化了就会通知相应的指令调用指令的方法由对做更新这就实现了数据驱动的变化同时还会对做事件监听如果发生变化监听到就会修改相应的单向数据流所有的都使得其父子之间形成了一个单向下行绑定父级的更新会向下流动到子组件中但是反过来则不行这样会防止从子组件意外改变父级组件的状态从而导致你的应用的数据流向难以理解额外的每次父级组件发生更新时子组件中所有的都将会刷新为最新的值这意味着你不应该在一个子组件内部改变如果你这样做了会在浏览器的控制台中发出警告父级的更新会向下流动到子组件中每次父级组件发生更新时子组件中所有的都将会刷新为最新的值监听数组首先第一点是要看数组里面是不是还存在对象如果存在对象的话在进行深层遍历是否还依然存在对象再把对象进行监听然后数组的改变实质上只是几个方法什么重写了这几个方法只要在调用这些方法的时候做出回调更新就可以了解释就是当页面上的元素被重新渲染之后才会执行回调函数中的代码涉及事件循环机制正是因为是异步更新所以当我们修改数据之后节点的内容不会立即修改我们这样获取节点的新内容的时候获取的还是旧的内容应用想要在生命周期函数中的操作可以使用回调函数在数据改变后要执行的操作而这个操作需要等数据改变后而改变结构的时候才进行操作需要用到在一个中多次更新数据页面只会更新一次数据被页面引用会收集到页面的被修改时会通知所有收集到的进行更新如果一时间被修改三次时按道理应该会通知三次更新那么页面会更新三次但是最后只会更新一次这是因为当数据变化后把函数存放进的回调数组中并且会做过滤通过来判断回调数组中是否已经存在这个的更新函数不存在才之后时遍历回调数组便会执行了更新所以当三次修改数据的时候会回调数组三个但是只有第一次是成功的其他的会被过滤掉因为已经存在了所以不管你修改多少次数据的回调数组中只存在唯一一个从而页面只会更新一次生命周期实例化创建初始化数据编译模板挂载渲染数据的更新渲染以及销毁提供了一些生命周期函数我们可以编写代码使得被实例化的过程中能够完成我们的需求创建之前此时还没有和加一些效果创建完成此时和可以使用了不能访问节点在之后之前如果没有选项的话那么此时生命周期结束停止编译如果有则继续在渲染之前压面呈现的是未经编译的结构所有对的操作都不奏效页面已经渲染完成这个时候可以操作了但是是获取不了元素的高度等属性的如果想要获取需要使用开启定时器发送网络请求绑定自定义事件等初始化操作数据是新的页面是旧的页面与数据保持同步在实例销毁之前此时指令仍然可以使用关闭定时器取消订阅消息解绑自定义事件实例销毁后另外还有独有的生命周期分别为和用包裹的组件在切换时不会进行销毁而是缓存到内存中并执行钩子函数命中缓存渲染后会执行钩子函数就是当页面上的元素被重新渲染之后才会执行回调函数中的代码的区别计算属性依赖其他属性当其他属性改变的时候下一次获取值时也会改变的值会有缓存监控自己定义的变量改变量不在中声明而是在里面定义计算属性不能向服务器发送请求或者执行异步任务监听属性的变化需要在数据变化时执行异步或开销较大的操作时使用定义的变量在中声明如果想深度监听的话后面加一个如果想监听完立马运行的话后面加一个而对于只要发生重新渲染调用总会执行该函数当一个属性受多个属性影响的时候使用例购物车商品结算功能当一条数据影响多条数据的时候使用例搜索数据性能优化图片懒加载一张图片就是一个标签浏览器是否发起请求图片是根据的属性所以实现懒加载的关键就是在图片没有进入可视区域时先不给的赋值这样浏览器就不会发送请求了等到图片进入可视区域再给赋值路由懒加载将路由相关的组件不再直接导入了而是改写成异步组件的写法只有当函数被调用的时候才去加载对应的组件内容路由懒加载就是只加载你当前点击的那个模块内容分发网络采用更多的服务器分布于用户访问相对集中的地方当用户访问时就会访问最近的服务器上响应用户的请求使用字体图标代替图片图标压缩文件通过向请求头中的头添加标识来开启这一功能当然服务器也得支持这一功能长列表虚拟滚动只渲染可视区域的列表项非可见区域的不渲染在滚动时动态更新可视区域原理计算出列表的总高度并在触发滚动事件时根据滚动长度实时更新预留缓冲区域高度以此来从列表数据中截取的一个插件库专门用来实现应用原理检测的变化截获地址然后解析来匹配路由规则理解一个路由就是一组映射关系多个路由需要路由器进行管理前端路由是路径是组件实现切换指定展示位置若是多级路由可用进行配置两种方式进行传参传参和进行传参或者接收参数的属性控制路由跳转时操作浏览器历史记录的模式浏览器的历史记录有两种写入方式分别为和是追加历史记录是替换当前记录路由跳转时候默认为如何开启模式编程式路由导航的两个前进后退可前进也可后退让不展示的路由组件保持挂载不被销毁缓存多个用数组缓存一个用字符串和作用路由组件所独有的两个钩子用于捕获路由组件的激活状态路由组件失活时触发应用可以将定时器写在被激活时里销毁定时器写在失活里组件跳转时会被触发路由守卫全局守卫前置和后置独享守卫组件内守卫进入守卫和离开守卫作用对路由进行权限控制全局守卫前置和后置全局前置守卫初始化时执行每次路由切换前执行判断当前路由是否需要进行权限控制权限控制的具体规则放行暂无权限查看放行全局后置守卫初始化时执行每次路由切换后执行修改网页的独享守卫判断当前路由是否需要进行权限控制暂无权限查看组件内守卫进入守卫通过路由规则进入该组件时被调用离开守卫通过路由规则离开该组件时被调用路由模式模式模式是一种把前端路由的路径用井号拼接在真实后面的模式当井号后面的路径发生变化时浏览器并不会重新发起请求而是会触发事件不会被包括在请求中变化会触发网页跳转即浏览器的前进和后退通过的方式来监听的改变借此实现无刷新跳转的功能可以改变但是不会触发页面重新加载不会出现在中首先本来是拿来做页面定位的如果拿来做路由的话原来的锚点功能就不能用了其次的传参是基于的如果要传递复杂的数据会有体积的限制模式利用的中新增的两个和和一个事件监听变化每次刷新会重新像后端请求整个网址也就是重新请求服务器如果后端没有及时响应就会报错模式不仅可以在里放参数还可以将数据存放在一个特定的对象中修改历史状态包括了中新增的和方法这两个方法应用于浏览器的历史记录栈提供了对历史记录进行修改的功能只是当他们进行修改时虽然修改了但浏览器不会立即向后端发送请求如果要做到改变但又不刷新页面的效果就需要前端用上这两个切换历史状态包括三个方法对应浏览器的前进后退跳转操作两种模式对比模式的设置的新可以是与当前同源的任意而只可修改后面的部分因此只能设置与当前同文档的设置的新可以与当前一模一样这样也会把记录添加到栈中而设置的新值必须与原来不一样才会触发动作将记录添加到栈中通过参数可以添加任意类型的数据到记录中而只可添加短字符串可额外设置属性供后续使用模式下仅符号之前的会被包含在请求中后端如果没有做到对路由的全覆盖也不会返回错误模式下前端的必须和实际向后端发起请求的一致如果没有对用的路由处理将返回错误怎么定义的动态路由怎么获取传过来的动态参数在目录下的文件中对属性加上使用对象的获取动态参数算法算法是指对新旧虚拟节点进行对比并返回一个对象用来存储两个节点不同的地方最后利用记录的消息局部更新算法算法是虚拟节点的比较不同认为是不同节点进行值的比较先进行同级比较然后再比较是不是一方有儿子一方没儿子和在中当数据发生改变的时候组件数就会自顶向下的全重新页面重新生成新的虚拟新旧进行比较进行打补丁的方式局部更新所以为了避免组件更新而引起不必要的子组件更新可以再做逻辑判断减少不必要的以及重新生成虚拟首先对新集合进行遍历通过唯一值来判断新旧集合中是否存在相同的节点如果没有的话就创建如果有的话就会将节点在新集合中的位置和老集合中的位置进行比较如果不同则进行移动操作否则就不操作如果在遍历的过程中发现在新集合中没有就会进行删除操作在中通过吧属性全部转为同时实例对象会在组件渲染时将属性记录为当中的被调用时通知重新计算使得关联组件更新新旧集合各有头尾的变量他们的各变量相互比较一共有四种比较方式如果四种都没匹配则会匹配值借助值找到可复用的节点在进行相关操作虚拟概述本质上是和之间的一个映射缓存它表现为一个能够描述结构及其属性信息的对象主要存储在内存中虚拟是一个对象存储在内存之中能够描述真实当数据变化的时候生成新的对比新旧虚拟的差异将差异更新到真实上虚拟优缺点缺点首次渲染大量时由于多了一层虚拟的计算会比插入慢优点减少了操作减少了回流与重绘保证性能的下限但是它具备局部更新的能力所以大部分时候还是比正常的性能高很多的的主要用在虚拟算法中每个虚拟节点有一个唯一标识通过对比新旧节点的来判断节点是否改变用就可以大大提高渲染效率使用作为可能会引发的问题若对数据进行逆序添加逆序删除等破坏顺序操作会产尘没有必要的真实更新界面效果没问题但效率低如果结构中还包含输入类的例如标签会产生错误更新界面有问题组件之间的通信父传子父组件设置子组件设置接受不能直接修改父组件的数据使用通信子组件用接收传递的值绑定的属性名自己决定在子组件中通过方法触发属性名事件实现父组件子组件值同时变化属性名要修改的值使用通信子组件用接收传递的值在子组件中通过方法触发事件实现父组件子组件值同时变化子传父自定义事件在父组件绑定自定义事件在子组件通过触发事件第一个参数为事件名称第二个参数为要传递的参数通过父组件给子组件传递函数类型的实现子给父传递如果在普通的元素上引用指向的就是该元素如果在子组件上引用的指向就是子组件实例然后父组件就可以通过主动获取子组件的属性或者调用子组件的方法任意组件传说中的安装全局事件总线就是当前应用的使用在需要向外部发送自定义事件的组件内通过发送数据在需要接收外部事件的组件内通过监听事件的触发并接受数据集中式存储管理所有组件的状态存储数据的获取数据最好推荐使用硬要使用的话可以用先引用放在中方法名方法名值为一个对象包含多个用于返回数据的函数函数第一个参数为对中的数据进行操作和加工同步操作数据的值为一个对象包含多个响应用户动作的回调函数组件中使用方法名数据触发也可使用使用方法和以上一样异步操作数据的值为一个对象包含多个响应用户动作的回调函数通过来触发中函数的调用组件中使用方法名数据触发也可使用使用方法和以上一样一个是一个的配置对象引用先安装依赖在项目目录中建立文件夹在文件夹下新建文件写入不是在生产环境为创建实例对象在不是生产环境下都开启严格模式然后再文件中引入这么写的中的数据是保存在运行内存中的当页面刷新时页面会重新加载实例里面的数据就会被重新赋值这样就会出现页面刷新中的数据丢失的问题如何解决浏览器刷新数据丢失问题呢方法一全局监听页面刷新的时候将里的值存到中然后从中获取再赋值给并移除中的数据安装插件在实例对象后添加插件默认使用来存储数据若要实现无痕浏览该如何实现呢有哪几种钩子函数全局守卫前置和后置独享守卫组件内守卫进入守卫和离开守卫全局前置守卫初始化时执行每次路由切换前执行判断当前路由是否需要进行权限控制全局后置守卫初始化时执行每次路由切换后执行为什么组件中是个函数在底层中在每次创建组件的时候都会一个实例对象他们的会挂载到的原型上共享如果是一个对象的话所有人都可以修改但是如果是一个函数返回值的话就可以创建一个私有作用域来避免互相污染语法糖绑定响应式数据触发事件并触发数据用于表单数据的双向绑定监听用户的输入事件已更新数据初始值为实例的数据作为数据来源父子组件中使用通信子组件用接收传递的值一定要叫在子组件中通过方法触发事件实现父组件子组件值同时变化组件绑定父组件子组件和浏览器解析不出代码会将它当做普通文本就可以解析为标签而只会解析为文本可能会造成攻击会替换掉子标签和的双向数据绑定是利用的一个对数据进行劫持结合发布订阅模式的方式来实现的中使用了的对数据代理通过函数给每一个对象都包一层通过监听属性的变化从而实现对数据的监控可以监听动态新增的属性可以监听删除的属性可以监听数组的变化采用编写使用的优势可直接监听数组类型的数据变化监听的目标为对象本身不需要像一样遍历每个属性有一定的性能提升可拦截等种方法而不行直接实现对象属性的新增删除的中的数据如果是对象的话会把它的属性转为的和使之变为响应式的如果在实例创建之后添加新的属性到实例上它不会触发视图更新比如中有一个对象具有和属性想追加一个属性增加成功但是不贵在视图上进行显示因为在创建实例的时候缺少了监听的属性直接在中用方法添加进去和在和用在同一个元素上时因为要比的优先级高所以会先执行循环再进行判断这样无论条件判断的结果如何循环都会执行所以要避免她们用在一起如果需要的话可以在外层加一个用在上这样就可以实现先判断再根据判断结果决定是否执行循环了和是动态的向树内添加或者删除元素是通过设置元素的样式属性控制显隐适合频繁切换适合运行条件不大可能改变插槽通俗的理解就是占坑在组件模板中占好了位置当使用该组件标签时候组件标签里面的内容就会自动填坑让父组件可以向子组件指定位置插入结构也是一种组件间通信的方式作用域插槽数据在组件的自身但根据数据生成的结构需要组件的使用者来决定通过来接收子组件传过来的插槽数据再根据插槽数据来填充插槽的内容自定义事件一种组件间通信的方式若想让自定义事件只能触发一次可以使用修饰符或方法触发自定义事件数据解绑自定义事件在使用计算属性时函数名与中的数据名可以同名吗不可以在初始化的时会依次绑定到上因此当方法名与数据名重复时会覆盖掉上一个打包后静态资源路径确定线上环境是否在根路径上配置资源根目录和字段不一致和如果项目是根路径上用都行如果是在这个路径上用相对路径需模式也可以用在路径上如果需要本地和线上保持一致可以用环境做判断设置不同的值确定静态文件放置的位置如果放在不经过打包放在又分使用绝对路径和相对路径如果放在经过打包使用的是相对路径路径是否是动态的如果是动态需要用引入动态设置中和请求数据比提前一般在中发送请求就可以但无法操作如果涉及到需要页面加载完成之后的话就用多个后端接口中把所有的服务人员的地址代理都写进去然后动态地更改接口的当选项对象中有渲染函数时构造函数将直接使用渲染函数渲染树当选项对象中没有渲染函数时构造函数首先通过将模板编译生成渲染函数然后再渲染树而当选项对象中既没有渲染函数也没有模板时会通过属性获取挂载元素的来作为模板并编译生成渲染函数换言之在进行树的渲染时渲染函数的优先级最高次之且需编译成渲染函数而挂载点属性对应的元素若存在则在前两者均不存在时其才会用于编译与渲染编译模板中的模板无法被浏览器解析并渲染因为这不属于浏览器的标准不是正确的语法所有需要将转化成一个函数这样浏览器就可以执行这一个函数并渲染出对应的元素就可以让视图跑起来了这一个转化的过程就成为模板编译模板编译又分三个阶段解析阶段使用大量的正则表达式对字符串进行解析将标签指令属性等转化为抽象语法树优化阶段遍历找到其中的一些静态节点并进行标记方便在页面重渲染的时候进行比较时直接跳过这一些静态节点优化的性能生成阶段将最终的转化为函数字符串首页白屏渲染路由懒加载当用户打开首页时会一次性加载所有的资源造成首页加载很慢降低用户体验使用的动态加载模块组件懒加载当组件复用性很高或者文件较大时或者用户触发时才会加载该组件骨架屏在项目打包时将骨架屏的内容放到文件的根节点中长列表虚拟滚动只渲染可视区域的列表项非可见区域的不渲染在滚动时动态更新可视区域原理计算出列表的总高度并在触发滚动事件时根据滚动长度实时更新预留缓冲区域高度以此来从列表数据中截取图片懒加载由于浏览器会自动对页面中的标签的属性发送请求并下载图片可以通过自定义属性先暂存的值然后在图片出现在屏幕可视区域的时候再将的值重新赋值到的属性异步加载是渲染完在执行是加载完就执行图片转格式优化长任务为什么只有一个根元素创建实例时只能有一个入口也就是一个根节点再通过此根节点来递归遍历所有节点这也是算法所必需的数据发生改变页面会更新吗如何实现异步更新的不会检测到实例创建时不存在与中的变量的改变不会检测到中对象属性的动态添加和删除无法通过数组索引或者赋值也无法直接改变数组的长度异步获取接口数据结构不发生变化实现在更新时是异步执行的只要侦听到数据变化将开启一个队列并缓冲在同一事件循环中发生的所有数据变更如果同一个被多次触发只会被推入到队列中一次这种在缓冲时去除重复数据对于避免不必要的计算和操作是非常重要的然后在下一个的事件循环中刷新队列并执行实际已去重的工作的函数虚拟到真实的过程实现方法挂载遍历整个树构建出真实的树接收三个参数节点属性子节点通过判断生成一个真实的元素的理解模型视图视图模型的核心主要用来处理业务逻辑当数据发生变化能够监听到数据的这种变化然后通知到对应的视图做自动更新当用户操作视图也能监听到视图的变化然后通知数据做改动实现了数据的双向绑定的为控制层缺点所有的业逻辑都在控制层中处理不利于维护不适合小型和中型项目中的作用是用于追踪那些列表重元素被修改呗添加或者被移除的辅助标识利用来识别组件相同的认为是同一个组件这样相同的对应组件就不会被创建有了属性就可以与组件建立了一种对应关系根据来决定销毁重新创建组件还是更新组件相同若组件属性有所变化则只更新组件对应的属性没有变化则不更新值不同则先销毁该组件然后重新创建该组件的设计思想组件化每个组件都符合开放封闭原则封闭是针对渲染工作流来说的指的是组件内部的状态有自身维护只处理内部的渲染逻辑开放是针对组件通信来说的指的是不同组件可以通过来进行数据交互数据驱动视图如果要渲染界面不应该直接操作而是通过修改数据的方式来驱动视图更新虚拟虚拟是对真实的印射通过新旧虚拟对比得到需要更新的部分是什么和的区别是的语法糖他允许在中写不能瘪浏览器直接识别需要通过编译工具转化为执行区别可以被打包工具直接编译不需要额外转换需要通过编译他是的语法糖是的语法扩展允许在中写是原生写法需要通过标签引入为什么在文件中没有使用也要在文件顶部只要使用了就需要引用因为本质上就是为什么自定义组件首字母要大写通过转义时调用了函数他接受三个参数分别是分别是元素类型元素属性子元素如果组件首字母为小写则会被当成字符串进行传递在创建虚拟的时候就会把它当成一个标签而如果是大写就会当成一个变量进行传递知道他是个自定义组件组建为什么只能有一个根元素为什么不能返回多个元素组件最后会被编译为函数函数的返回值只能是一个如果不用单独的根节点包裹就会并列返回多个值这在中是不允许的的虚拟是一个树状结构树的根节点只能是一个如果有多个根节点则无法确认实在那棵树上进行更新可以将元素列表加到一个分组中而且不会创建额外的节点的生命周期生名周期指的是组件实例从创建到销毁的流程函数组件没有生命周期只有类组件才有因为只有组件才会创建组件实例挂载可以进行和的初始化第一次渲染调用可以访问进行异步请求和定时器更新返回一个布尔值默认返回可以通过这个生命周期钩子进行性能优化确认不需要更新组件时调用在组件完成更新后调用卸载组件从中被移除的时候调用错误捕获在中使用事件机制基于浏览器的事件机制实现了一套自身的事件机制它符合规范包括事件触发事件冒泡事件捕获事件合成和事件派发等所有的事件绑定在上而不是绑定在目标元素上减少了内存开销自身实现了一套冒泡机制不能通过阻止冒泡通过实现了时间合成事件处理为什么要手动绑定组件会被编译为在中他的丢失了并不是有组件实例调用的因此需要手动绑定和区别性能优化手段使用使用正确的拆分尽可能小的可复用组件使用错误边界使用和延迟加载不需要立马使用的组件提供了让子组件渲染在除了父组件之外的节点的方式他接受两个参数第一个元素是需要渲染的元素第二个是渲染的地方元素组件通信概述父组件传递给子组件的数据子组件不能修改该数据在组件中通过的方式获取使用子组件父组件约束因为从开始移除了约束所以需要安装第三方模块实现子传父父组件子组件传递给父组件数据提供了一种跨层级组建数据传递的方法他解决了组件嵌套造成数据来源不清晰多余的变量定义等问题使用新建文件创建一个新建组件组件使用函数组件使用概述允许在函数组件中使用对象在值发生改变时重新渲染问题的值发生改变无论子组件是否引用都会导致子组件重新渲染需要接受作为参数概述是的替代方案能够解决状态更新逻辑散落在中不能独立复用不方便测试使用新建组件新建文件返回下标调用是一个状态管理库应用于跨层级组建数据共享与通信一些需要持久化的全局数据比如用户登录信息新项目项目名项目名老项目项目引入创建检测的变化数据发生改变概述是一个纯函数会根据不同的对象返回一个新的纯函数不修改传入的参数不执行有副作用的操作比如计时器等等不调用非纯函数如练习篮球一年半返回下标概述用于将多个合并为一个概述用于组件中获取的概述返回函数的引用概述因为在中只能同步操作那么要想异步处理就只能在组件中先进行异步操作然后成功后再但是会让的逻辑散落在中不易于后期管理接用该插件可以实现一个函数然后在这个函数中处理异步文件三方模块通过该中间件注册配置创建检测的状态变化数据发生改变文件同步类似于登陆失败文件文件使用和的区别相同点数据驱动视图组件化思想都是用虚拟不同点核心思想不通为渐进式框架门槛较低进行数据劫持或者代理函数式编程数据不可变以及单向数据流组件写法差异单文件组建格式即写在同一个文件为和都写进中算法不同首先对新集合进行遍历通过唯一值来判断新旧集合中是否存在相同的节点如果没有的话就创建如果有的话就会将节点在新集合中的位置和老集合中的位置进行比较如果不同则进行移动操作否则就不操作如果在遍历的过程中发现在新集合中没有就会进行删除操作新旧集合各有头尾的变量他们的各变量相互比较一共有四种比较方式如果四种都没匹配则会匹配值借助值找到可复用的节点在进行相关操作响应式原理不同依赖收集自动依赖数据可变递归监听中的所有属性直接修改当数据改变时自动找到引用组件重新渲染基于状态手动优化数据不可变需要驱动新的替换老的当数据改变时以组件为根目录默认全部重新渲染所以中会需要这个生命周期函数来进行控制是同步还是异步的是一个异步方法但是在等定时器里逃脱了对他的掌控变成了同步方法实现机制类似于的和浏览器的时间循环机制每个都会被加入到任务队列当中多次对同一个使用只会返回最后一次的结果因为他不是立刻就更新而是先放在任务队列中等时机成熟在执行批量更新而在以后使用了后所有都是异步批量执行渲染流程用描述页面经过编译为执行后产生并不会直接渲染而是会先转换为在进行渲染转换为的过程叫转换过程会创建全部转换完成后会一次性到这个过程不是一次性的而是可打断的常用项目总结登陆创建登录组件在文件夹中创建一个登录组件在路由文件中导入登录组件并添加路由规则重定向路由当用户访问时会自动定向到登录路由登录组件路由登录页面基本布局因为在安装插件时配置的是按需导入因此需要在文件夹中的文件中导入需要用到的组件并注册为全局可用登录表单数据绑定根据在官网我们所选择的表单组件中绑定数据的方式去绑定我们需要的数据给密码框添加属性将密码隐藏登录表单数据验证根据在官网中组件提供了表单验证的功能只需给表单绑定属性并传入约定的验证规则并将的属性设置为需校验的字段名即点击重置按钮实现表单重置首先通过给表单添加一个引用对象之后只要获取到这个引用对象可以任意命名只要合法就可以获取到这个表单的实例对象给重置按钮添加单机事件并命名事件处理函数使用官网在表单组件中提供的方法对整个表单进行重置将所有字段值重置为初始值并移除校验结果表单实例方法就可以重置表单点击登录对表单数据进行预验证在发送请求之前表单组件中提供的对整个表单进行校验的方法参数为一个回调函数该回调函数会在校验结束后被调用并传入两个参数是否校验成功和未通过校验的字段若不传入回调函数则会返回一个表单实例方法就可以对表单进行预验证发送登录请求通过预验证后在入口文件导入将其挂载到的原型对象上并配置请求根路径在登录事件处理函数中发送请求异步使用关键字处理异步代码返回值是一个对象其中只有属性中包含的是有用的服务器返回数据所以将其解构赋值到一个变量告诉用户登录结果消息提示的组件在文件中导入需要用到的组件该组件需要进行全局挂载而不是全局注册根据接收到的登录请求返回的状态码来提示用户是否登录成功登录成功之后的行为将登录成功后服务器返回的保存到客户端的中保持登录状态和保存期限不同在窗口关闭后会删除保存的数据没有保存期限所有接口除了登录接口外都需要登录之后才能访问通过编程式导航跳转到后台主页路由地址是路由导航守卫在路由文件中添加导航守卫如果用户没有登录用户可以通过直接输入地址访问页面这是不合理的因此需要重新导航到登录页面挂载路由导航守卫代表将要访问的路径代表从那个路径跳转而来是一个函数表示是否放行放行强制跳转获取实现退出功能在组件中暂时添加一个退出按钮给按钮绑定单机事件并命名事件处理函数定义事件处理函数基于实现退出功能只需销毁本地即可登录验证项目的优化在可视化的面板中查看控制台和分析面板看到项目中所存在的问题资源文件和依赖项文件等文件大小是否需要优化组件按需加载第三方库启用可以通过的节点来配置并加载外部的资源路由懒加载将路由相关的组件不再直接导入了而是改写成异步组件的写法只有当函数被调用的时候才去加载对应的组件内容路由懒加载就是只加载你当前点击的那个模块开启配置减小文件体积使传输速度更快安装相应包导入包启用中间件',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-11-06 10:25:24',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">野菜</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AJAX/" style="font-size: 1.05rem;">AJAX<sup>1</sup></a><a href="/tags/Axios/" style="font-size: 1.05rem;">Axios<sup>1</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>1</sup></a><a href="/tags/Node-js/" style="font-size: 1.05rem;">Node.js<sup>1</sup></a><a href="/tags/React/" style="font-size: 1.05rem;">React<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 1.05rem;">TypeScript<sup>1</sup></a><a href="/tags/Vue/" style="font-size: 1.05rem;">Vue<sup>3</sup></a><a href="/tags/Vue3/" style="font-size: 1.05rem;">Vue3<sup>1</sup></a><a href="/tags/canvas/" style="font-size: 1.05rem;">canvas<sup>1</sup></a><a href="/tags/host/" style="font-size: 1.05rem;">host<sup>1</sup></a><a href="/tags/js/" style="font-size: 1.05rem;">js<sup>3</sup></a><a href="/tags/this/" style="font-size: 1.05rem;">this<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">博客<sup>1</sup></a><a href="/tags/%E6%8C%87%E4%BB%A4/" style="font-size: 1.05rem;">指令<sup>1</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">教程<sup>1</sup></a><a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 1.05rem;">框架<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">笔记<sup>3</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">系统<sup>4</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem;">编程<sup>12</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 1.05rem;">面试题<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" style="font-size: 1.05rem;">项目总结<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/11/"><span class="card-archive-list-date">十一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/10/"><span class="card-archive-list-date">十月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/04/"><span class="card-archive-list-date">四月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/11/"><span class="card-archive-list-date">十一月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试题</span></a></span></div></div><h1 class="post-title" itemprop="name headline">面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2021-01-01T02:00:00.000Z" title="发表于 2021-01-01 10:00:00">2021-01-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-11-06T02:25:24.987Z" title="更新于 2025-11-06 10:25:24">2025-11-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://api.gumengya.com/Api/FjImg?format=image&amp;_t=4"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2021/01/01/face/"><header><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a><a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" tabindex="-1" itemprop="url">面试题</a><h1 id="CrawlerTitle" itemprop="name headline">面试题</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">野菜</span><time itemprop="dateCreated datePublished" datetime="2021-01-01T02:00:00.000Z" title="发表于 2021-01-01 10:00:00">2021-01-01</time><time itemprop="dateCreated datePublished" datetime="2025-11-06T02:25:24.987Z" title="更新于 2025-11-06 10:25:24">2025-11-06</time></header><p>[TOC]</p>
<ul>
<li><a href="#html">HTML</a><ul>
<li><a href="#1--html5%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96">1.  html5有什么优化</a></li>
<li><a href="#2-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3html%E8%AF%AD%E4%B9%89%E5%8C%96">2. 如何理解HTML语义化</a></li>
<li><a href="#3-meta%E6%A0%87%E7%AD%BE">3. meta标签</a></li>
</ul>
</li>
<li><a href="#css">CSS</a><ul>
<li><a href="#0-css3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96">0. css3有什么优化</a></li>
<li><a href="#1-css%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7">1. CSS选择器及优先级</a></li>
<li><a href="#2-position-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB">2. position 属性的值有哪些及其区别</a></li>
<li><a href="#3-box-sizing%E5%B1%9E%E6%80%A7">3. box-sizing属性</a></li>
<li><a href="#4-css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B">4. CSS 盒子模型</a></li>
<li><a href="#5-bfc%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8Cifc%E8%A1%8C%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B">5. BFC（块级格式上下文）和IFC(行级格式化上下)</a></li>
<li><a href="#6-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD">6. 水平垂直居中</a><ul>
<li><a href="#%E8%87%AA%E9%80%82%E5%BA%94%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80">自适应两栏布局</a></li>
<li><a href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80">三栏布局</a></li>
</ul>
</li>
<li><a href="#7-%E7%94%A8css%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E7%AC%A6%E5%8F%B7">7. 用CSS实现三角符号</a></li>
<li><a href="#8-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%E6%9F%A5">8. 常见的布局类型（查）</a></li>
<li><a href="#9-%E6%B5%AE%E5%8A%A8%E6%9F%A5">9. 浮动（查）</a></li>
<li><a href="#10-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0">10. 常见的行内元素和块级元素</a></li>
<li><a href="#11-pxemremvwvhrpx%E7%AD%89%E5%8D%95%E4%BD%8D%E7%9A%84%E7%89%B9%E6%80%A7">11. px,em,rem,vw,vh,rpx等单位的特性</a></li>
<li><a href="#12-%E4%BB%80%E4%B9%88%E6%98%AFdom%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%9F%A5">12. <strong>什么是DOM事件流？什么是事件委托</strong>(查)</a></li>
<li><a href="#13-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E6%8D%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%9F%A5">13. 事件冒泡和事件捕捉有什么区别（查）</a></li>
<li><a href="#14-link%E5%92%8Cimport">14. link和@import</a></li>
<li><a href="#15-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80">15. 响应式布局</a></li>
<li><a href="#16-%E5%85%83%E7%B4%A0%E4%B8%8D%E5%8F%AF%E8%A7%81">16. 元素不可见</a></li>
</ul>
</li>
<li><a href="#js">JS</a><ul>
<li><a href="#0-object%E5%B8%B8%E7%94%A8%E7%9A%84api">0. Object常用的API</a></li>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1. 基本数据类型</a></li>
<li><a href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B">2. 数据类型检测</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">数据类型转换：</a></li>
<li><a href="#4-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">4. 作用域和作用域链</a></li>
<li><a href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85">5. 什么是闭包</a></li>
<li><a href="#6-this%E7%9A%84%E6%8C%87%E5%90%91">6. this的指向</a></li>
<li><a href="#7-new-%E5%AE%9E%E7%8E%B0">7. new 实现</a></li>
<li><a href="#9--%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB">9. &#x3D;&#x3D; 和&#x3D;&#x3D;&#x3D;的区别</a></li>
<li><a href="#10-nan--nan%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88">10. <strong><code>NaN === NaN</code>返回什么</strong></a></li>
<li><a href="#11-%E6%89%8B%E5%86%99callapplybind%E6%9F%A5">11. <strong>手写call、apply、bind</strong>（查）</a></li>
<li><a href="#12-%E6%89%A7%E8%A1%8C%E6%A0%88%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87">12. 执行栈和执行上下文</a></li>
<li><a href="#13-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE">13. 原型，原型链</a></li>
<li><a href="#14-js-%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F">14. <strong>JS 中的常用的继承方式</strong></a></li>
<li><a href="#15-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">15. 内存泄漏</a></li>
<li><a href="#16-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">16. 垃圾回收机制</a></li>
<li><a href="#17-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D">17. 深拷贝和浅拷贝</a></li>
<li><a href="#18-js%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B">18. js是单线程</a></li>
<li><a href="#19-promise">19. promise</a></li>
<li><a href="#20-async%E5%92%8Cawait">20. async和await</a></li>
<li><a href="#21-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1">21. 宏任务和微任务</a></li>
<li><a href="#22-js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6event-loop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">22. js执行机制(event loop 事件循环)</a></li>
<li><a href="#24-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81">24. 防抖和节流</a></li>
<li><a href="#26-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9F%A5">26. 常用的数组方法（查）</a><ul>
<li><a href="#1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">1. 冒泡排序</a></li>
<li><a href="#2-%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC">2. 数组最大值</a></li>
<li><a href="#3-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D">3. 数组去重</a></li>
<li><a href="#4-%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84">4. 反转数组</a></li>
<li><a href="#5-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84">5. 遍历数组</a><ul>
<li><a href="#1-for-of"><strong>1. for of</strong></a></li>
<li><a href="#2-foreach"><strong>2. forEach</strong></a></li>
<li><a href="#3-some">3. some</a></li>
<li><a href="#4-every">4. every</a></li>
<li><a href="#5-map">5. map</a></li>
<li><a href="#6-filter">6. filter</a></li>
<li><a href="#7-find">7. find()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#28-bom%E5%92%8Cdom%E7%9A%84%E5%8C%BA%E5%88%AB">28. <strong>bom和dom的区别</strong></a></li>
<li><a href="#29-js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F">29. JS性能优化的方式</a></li>
<li><a href="#30-defer-%E5%92%8C-async">30. defer 和 async</a></li>
<li><a href="#31-set%E5%92%8Cmap">31. set和map</a></li>
<li><a href="#32-for-of%E5%92%8Cfor-in">32. for of和for in</a></li>
<li><a href="#25-js%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%E6%9F%A5">25. js遍历数组的方法（查）</a></li>
<li><a href="#33-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D">33. 数组去重</a></li>
<li><a href="#34-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F">34. 数组排序</a></li>
<li><a href="#35-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA">35. <strong>什么是暂时性死区？</strong></a></li>
<li><a href="#36-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96">36. 函数柯里化</a></li>
<li><a href="#37-null%E4%B8%8Eundefined%E7%9A%84%E5%8C%BA%E5%88%AB">37. null与undefined的区别</a></li>
<li><a href="#38-new-stringa%E5%92%8Cstringa">38. new String(‘a’)和String(‘a’)</a></li>
<li><a href="#39--%E5%92%8C--%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">39. || 和 &amp;&amp; 和！！操作符的返回值</a></li>
</ul>
</li>
<li><a href="#es6">ES6</a><ul>
<li><a href="#1-export-%E5%92%8C-export-default-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">1. export 和 export default 有什么区别</a></li>
<li><a href="#2-varletconst%E5%8C%BA%E5%88%AB">2. var&#x2F;let&#x2F;const区别</a></li>
<li><a href="#3-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB">3. 箭头函数和普通函数的区别</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a><ul>
<li><a href="#0-axios%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85">0. Axios的二次封装</a></li>
<li><a href="#1-%E8%B7%A8%E5%9F%9F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%BC%95%E8%B5%B7%E7%9A%84">1. 跨域（同源策略引起的）</a></li>
<li><a href="#2-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">2. 三次握手</a></li>
<li><a href="#3-%E7%8A%B6%E6%80%81%E7%A0%81">3. 状态码</a></li>
<li><a href="#4-http">4. http</a></li>
<li><a href="#5-localstoragesessionstoragecookiesession">5. <strong>localStorage、SessionStorage、cookie、session</strong></a></li>
<li><a href="#6-token%E5%92%8Cjwt">6. token和JWT</a></li>
<li><a href="#7-get%E5%92%8Cpost">7. get和post</a></li>
<li><a href="#8-tcp%E5%92%8Cudp%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">8. tcp和udp网络协议</a></li>
<li><a href="#9-tcp%E9%87%8D%E4%BC%A0">9. tcp重传</a></li>
<li><a href="#10-%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88----">10. <strong>从浏览器输入url后都经历了什么</strong>    ***</a></li>
<li><a href="#11-%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6">11. 回流和重绘，浏览器渲染机制</a></li>
<li><a href="#12-meta%E6%A0%87%E7%AD%BE">12. meta标签</a></li>
<li><a href="#13-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">13. 浏览器性能优化</a></li>
<li><a href="#14-%E7%99%BB%E9%99%86%E5%AE%9E%E7%8E%B0">14. 登陆实现</a></li>
<li><a href="#15-xss%E8%B7%A8%E5%9F%9F%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%92%8Ccsrf%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">15. xss(跨域脚本攻击)和csrf(跨站请求伪造)</a></li>
<li><a href="#16-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98">16. 浏览器缓存</a></li>
<li><a href="#17-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">17. 进程和线程</a></li>
<li><a href="#18-url%E7%9A%84%E7%BB%93%E6%9E%84">18. url的结构</a></li>
<li><a href="#19-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%93%E6%9E%84">19. 请求报文和响应报文的结构</a></li>
</ul>
</li>
<li><a href="#vue">VUE</a><ul>
<li><a href="#vue%E7%9A%84%E4%BC%98%E7%82%B9">VUE的优点</a></li>
<li><a href="#spa%E9%A1%B5%E9%9D%A2">SPA页面：</a></li>
<li><a href="#1-vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86">1. vue双向绑定的原理</a></li>
<li><a href="#vue%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81">Vue单向数据流</a></li>
<li><a href="#2-vue%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84">2. Vue监听数组</a></li>
<li><a href="#3-nexttick">3. nextTick</a></li>
<li><a href="#4-vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">4. Vue生命周期</a></li>
<li><a href="#5-computed-watchmethod%E7%9A%84%E5%8C%BA%E5%88%AB">5. computed 、watch、method的区别</a></li>
<li><a href="#6-vue%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F">6. Vue优化方式</a></li>
<li><a href="#7-vue-router">7. Vue-router</a><br>- <a href="#2-history%E6%A8%A1%E5%BC%8F">2. history模式</a><br>- <a href="#3-%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94">3. 两种模式对比</a></li>
<li><a href="#8-diff%E7%AE%97%E6%B3%95">8. diff算法</a></li>
<li><a href="#9-%E8%99%9A%E6%8B%9Fdom%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">9. 虚拟DOM的优缺点</a></li>
<li><a href="#10-vue%E7%9A%84keyindex">10. Vue的key（index）</a></li>
<li><a href="#11-vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1vuex">11. vue组件之间的通信（vuex）</a></li>
<li><a href="#12-vue-router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0">12. <strong>Vue-router有哪几种钩子函数</strong></a></li>
<li><a href="#13-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%E4%B8%AD-data-%E6%98%AF%E4%B8%AA%E5%87%BD%E6%95%B0">13. <strong>为什么组件中 data 是个函数</strong></a></li>
<li><a href="#14-v-model">14. v-model</a></li>
<li><a href="#15-v-html%E5%92%8Cv-text">15. v-html和v-text</a></li>
<li><a href="#17-vue20%E5%92%8C30">17. vue2.0和3.0</a></li>
<li><a href="#18-vue%E7%9A%84set">18. <strong>vue的$set</strong></a></li>
<li><a href="#19-v-if%E5%92%8Cv-for">19. v-if和v-for</a></li>
<li><a href="#20-v-if-%E5%92%8C-v-show">20. <strong>v-if 和 v-show</strong></a></li>
<li><a href="#21-%E6%8F%92%E6%A7%BD">21. 插槽</a></li>
<li><a href="#22-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6">22. 自定义事件</a></li>
<li><a href="#23-%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E6%97%B6%E5%87%BD%E6%95%B0%E5%90%8D%E4%B8%8Edata%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8D%E5%8F%AF%E4%BB%A5%E5%90%8C%E5%90%8D%E5%90%97">23. 在使用计算属性时，函数名与data中的数据名可以同名吗</a></li>
<li><a href="#24-vue%E6%89%93%E5%8C%85%E5%90%8E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84">24. vue打包后静态资源路径</a></li>
<li><a href="#25-vue%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEimg">25. vue动态设置img</a></li>
<li><a href="#26-vue-%E4%B8%ADcreated%E5%92%8Cmounted%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE">26. vue 中created和mounted请求数据</a></li>
<li><a href="#27-%E5%A4%9A%E4%B8%AA%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3">27. 多个后端接口</a></li>
</ul>
</li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93">项目总结</a><ul>
<li><a href="#%E7%99%BB%E9%99%86">登陆</a></li>
<li><a href="#1-%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81">1. 登录验证</a></li>
<li><a href="#2-%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BC%98%E5%8C%96">2. 项目的优化</a></li>
</ul>
</li>
</ul>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h3 id="1-html5有什么优化"><a href="#1-html5有什么优化" class="headerlink" title="1.  html5有什么优化"></a>1.  html5有什么优化</h3><ul>
<li>语义化标签的出现<ul>
<li>header</li>
<li>footer</li>
<li>section 等等等等</li>
</ul>
</li>
<li>还有 input 的优化<ul>
<li>可以给它的 type 设置成 number、tel、email 等等</li>
</ul>
</li>
<li>增加了表单的优化<ul>
<li>placeholder、required、min&#x2F;max、multiple 等等</li>
</ul>
</li>
<li>增加了 canvas</li>
<li>增加了 audio播放音频文件的标签</li>
</ul>
<h3 id="2-如何理解HTML语义化"><a href="#2-如何理解HTML语义化" class="headerlink" title="2. 如何理解HTML语义化"></a>2. 如何理解HTML语义化</h3><p>概念：合理正确的使用语义化的标签来创建页面结构（正确的标签做正确的事）</p>
<p>为了避免大篇幅的没有语义的标签来构建页面。</p>
<p>标签：header nav main article section aside footer</p>
<p>优点：1. 在<code>没CSS样式的情况下，页面整体也会呈现很好的结构效果</code></p>
<pre><code>        2. `代码结构清晰`，易于阅读，
        2. `利于开发和维护` 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。
        2. `有利于搜索引擎优化（SEO）`，搜索引擎爬虫会根据不同的标签来赋予不同的权重
</code></pre>
<h3 id="3-meta标签"><a href="#3-meta标签" class="headerlink" title="3. meta标签"></a>3. meta标签</h3><p>为浏览器提供 html 的元信息</p>
<p>规定 html 字符编码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>设置移动端的视区窗口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta id=<span class="string">&quot;viewport&quot;</span> name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width; initial-scale=1.0; maximum-scale=1; user-scalable=no;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>设置 http 头</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=gb2312&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>图片403</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;referrer&quot;</span> content=<span class="string">&quot;no-referrer&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-src-和-href-的区别"><a href="#4-src-和-href-的区别" class="headerlink" title="4. src 和 href 的区别"></a>4. src 和 href 的区别</h3><ol>
<li>请求资源不同。<code>href</code>：超文本引用，用于建立文档与资源的联系，常用的有：link,a。<code>src</code>：将其所指向的资源下载并应用。</li>
<li>作用结果不同：<code>href</code>用于文档与资源之间建立联系。<code>src</code>请求到的资源替换当前内容。</li>
<li>浏览器的解析不同：<code>href</code>将资源解析成css文件，并行加载请求资源，不会阻塞对当前文档的处理。<code>src</code>会暂停其他资源的处理，直到该资源加载、解析和执行完毕。</li>
</ol>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h3 id="0-css3有什么优化"><a href="#0-css3有什么优化" class="headerlink" title="0. css3有什么优化"></a>0. css3有什么优化</h3><ul>
<li>Border-radius、Border-shadow、border-image</li>
<li>还有动画效果 translate3d，<strong>css3的 translate3d 可以开启 gpu 加速</strong>，所以在使用动画的时候尽量要 css3的 translate3d，而不是 position：absolute+top+left</li>
<li>box-sizing</li>
</ul>
<h3 id="1-CSS选择器及优先级"><a href="#1-CSS选择器及优先级" class="headerlink" title="1. CSS选择器及优先级"></a>1. CSS选择器及优先级</h3><p>带!important 标记的样式属性优先级最高； 样式表的来源相同时：<code>!important &gt; 行内样式&gt;嵌入样式和外链样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></p>
<h3 id="2-position-属性的值有哪些及其区别"><a href="#2-position-属性的值有哪些及其区别" class="headerlink" title="2. position 属性的值有哪些及其区别"></a>2. position 属性的值有哪些及其区别</h3><p><strong>固定定位 fixed</strong>： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。<br> <strong>相对定位 relative</strong>： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。<br> <strong>绝对定位 absolute</strong>： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于浏览器窗口。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。<br> <strong>粘性定位 sticky</strong>： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。<br> <strong>默认定位 Static</strong>： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 inherit: 规定应该从父元素继承 position 属性的值。</p>
<h3 id="3-box-sizing属性"><a href="#3-box-sizing属性" class="headerlink" title="3. box-sizing属性"></a>3. box-sizing属性</h3><p>box-sizing 规定两个并排的带边框的框，语法为 box-sizing：content-box&#x2F;border-box&#x2F;inherit<br> <strong>content-box</strong>：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。【标准盒子模型】<br> <strong>border-box</strong>：为元素设定的宽度和高度决定了元素的边框盒。【IE 盒子模型】<br> <strong>inherit</strong>：继承父元素的 box-sizing 值。</p>
<h3 id="4-CSS-盒子模型"><a href="#4-CSS-盒子模型" class="headerlink" title="4. CSS 盒子模型"></a>4. CSS 盒子模型</h3><p>CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。<br>在标准的盒子模型中，<code>width 指 content 部分的宽度</code>。<br>在 IE 盒子模型中，<code>width 表示 content+padding+border 这三个部分的宽度</code>。</p>
<h3 id="5-BFC（块级格式上下文）和IFC-行级格式化上下"><a href="#5-BFC（块级格式上下文）和IFC-行级格式化上下" class="headerlink" title="5. BFC（块级格式上下文）和IFC(行级格式化上下)"></a>5. BFC（块级格式上下文）和IFC(行级格式化上下)</h3><p><code>BFC</code> 是 <code>Block Formatting Context </code>的缩写，即块级格式化上下文。<code>BFC</code>是一个独立的渲染区域，规定了内部box如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算</p>
<p>创建：</p>
<ul>
<li>绝对定位元素（<code>position</code> 为 <code>absolute</code> 或 <code>fixed</code> ）。</li>
<li>行内块元素，即 <code>display</code> 为 <code>inline-block</code> 。</li>
<li><code>overflow</code> 的值不为 <code>visible</code> 。</li>
</ul>
<p>应用： 1.分属于不同的<code>BFC</code>时,可以防止<code>margin</code>重叠 2.清除内部浮动 3.自适应多栏布局</p>
<p>IFC：内联格式上下文</p>
<p>布局规则：1.内部的盒子会在水平方向，一个个地放置；<br>                        2.IFC的高度，由里面最高盒子的高度决定；<br>                        3.当一行不够放置的时候会自动切换到下一行</p>
<h3 id="6-水平垂直居中"><a href="#6-水平垂直居中" class="headerlink" title="6. 水平垂直居中"></a>6. 水平垂直居中</h3><ol>
<li><p>利用transform，设置 <code>left: 50%</code> 和 <code>top: 50%</code> 现将子元素左上角移到父元素中心位置，然后再通过 <code>translate</code> 来调整子元素的中心点到父元素的中心。该方法可以<strong>不定宽高</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  .<span class="property">father</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">son</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: absolute;</span><br><span class="line">  <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">  <span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line">  <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%, -<span class="number">50</span>%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用绝对定位，设置 <code>left: 50%</code> 和 <code>top: 50%</code> 现将子元素左上角移到父元素中心位置，然后再通过 <code>margin-left</code> 和 <code>margin-top</code> 以子元素自己的一半宽高进行负值赋值。该方法<strong>必须定宽高</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">father</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">son</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: absolute;</span><br><span class="line">  <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">  <span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 200px;</span><br><span class="line">  margin-<span class="attr">left</span>: -100px;</span><br><span class="line">  margin-<span class="attr">top</span>: -100px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 <code>flex</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">father</span> &#123;</span><br><span class="line">  <span class="attr">display</span>: flex;</span><br><span class="line">  justify-<span class="attr">content</span>: center;</span><br><span class="line">  align-<span class="attr">items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h4><p>通过BFC和浮动</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">content</span>&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">100</span>%</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">left</span>&#123;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    margin-<span class="attr">right</span>: 10px;</span><br><span class="line">    <span class="attr">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span>&#123;</span><br><span class="line">    <span class="attr">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">left</span>&#123;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    <span class="attr">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span>&#123;</span><br><span class="line">    margin-<span class="attr">left</span>: 210px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过定位</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">content</span>&#123;</span><br><span class="line">    <span class="attr">position</span>: relative;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">left</span>&#123;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span>&#123;</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">left</span>: 210px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过flex：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.content&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    display:flex;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    margin-right:10px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    flex:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h4><p>普通三栏：通过定位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.middle &#123;</span><br><span class="line">    margin-left: 210px;</span><br><span class="line">    margin-right: 210px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过浮动实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">    <span class="attr">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">left</span> &#123;</span><br><span class="line">    <span class="attr">float</span>: left;</span><br><span class="line">    background-<span class="attr">color</span>: gray;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    <span class="attr">height</span>: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span> &#123;</span><br><span class="line">    <span class="attr">float</span>: right;</span><br><span class="line">    background-<span class="attr">color</span>: gray;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    <span class="attr">height</span>: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">middle</span> &#123;</span><br><span class="line">    <span class="attr">height</span>: 200px;</span><br><span class="line">    background-<span class="attr">color</span>: lightgray;</span><br><span class="line">    margin-<span class="attr">left</span>: 210px;</span><br><span class="line">    margin-<span class="attr">right</span>: 210px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>圣杯布局：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">container</span> &#123;</span><br><span class="line">  padding-<span class="attr">left</span>: 220px;<span class="comment">//为左右栏腾出空间</span></span><br><span class="line">  padding-<span class="attr">right</span>: 220px;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">left</span> &#123;</span><br><span class="line">  <span class="attr">float</span>: left;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 400px;</span><br><span class="line">  <span class="attr">background</span>: red;</span><br><span class="line">  margin-<span class="attr">left</span>: -<span class="number">100</span>%;</span><br><span class="line">  <span class="attr">position</span>: relative;</span><br><span class="line">  <span class="attr">left</span>: -220px;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">center</span> &#123;</span><br><span class="line">  <span class="attr">float</span>: left;</span><br><span class="line">  <span class="attr">width</span>: <span class="number">100</span>%;</span><br><span class="line">  <span class="attr">height</span>: 500px;</span><br><span class="line">  <span class="attr">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span> &#123;</span><br><span class="line">  <span class="attr">float</span>: left;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 400px;</span><br><span class="line">  <span class="attr">background</span>: blue;</span><br><span class="line">  margin-<span class="attr">left</span>: -200px;</span><br><span class="line">  <span class="attr">position</span>: relative;</span><br><span class="line">  <span class="attr">right</span>: -220px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-用CSS实现三角符号"><a href="#7-用CSS实现三角符号" class="headerlink" title="7. 用CSS实现三角符号"></a>7. 用CSS实现三角符号</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div &#123; </span><br><span class="line">    <span class="attr">width</span>: 0px;   </span><br><span class="line">    <span class="attr">height</span>: 0px;  </span><br><span class="line">    border-<span class="attr">right</span>: 10px solid transparent;   </span><br><span class="line">    border-<span class="attr">top</span>: 30px solid #ff0;  </span><br><span class="line">    border-<span class="attr">left</span>: 10px solid transparent;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*记忆口诀：盒子宽高均为零，三面边框皆透明。 */</span></span><br></pre></td></tr></table></figure>



<h3 id="8-常见的布局类型（查）"><a href="#8-常见的布局类型（查）" class="headerlink" title="8. 常见的布局类型（查）"></a>8. 常见的布局类型（查）</h3><p>浮动，定位，flex,grid网格布局</p>
<p>浮动：</p>
<ul>
<li>优点：兼容性好</li>
<li>缺点：浮动会脱离标准文档流</li>
</ul>
<p>定位：</p>
<ul>
<li>优点：快捷</li>
<li>缺点：子元素也脱离了标准文档流，可用性差</li>
</ul>
<p>flex布局：弹性布局</p>
<ul>
<li>[<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]</a>:</li>
</ul>
<p>网格布局：</p>
<ul>
<li>[<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html]">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html]</a>:</li>
</ul>
<h3 id="9-浮动（查）"><a href="#9-浮动（查）" class="headerlink" title="9. 浮动（查）"></a>9. 浮动（查）</h3><p>设置浮动的图片，文字会环绕图片，设置浮动的块级元素，可以排列在一行，设置浮动的行内元素，可以设置宽高。</p>
<p>设置了浮动的元素会脱离文档流，如果父级盒子没有设置宽高，需要子盒子将她撑起来，则会造成高度塌陷。也会影响其他元素的排列。</p>
<ol>
<li><p>额外标签法（在最后一个浮动标签后，新加一个标签，给其设置clear:both）</p>
<p>新添加了一个标签，会造成不必要的渲染</p>
</li>
<li><p>父级添加overflow属性（overflow: hidden;）</p>
<p>写法方便简单，但是如果盒子中有定位元素超出了父级，则超出部分会隐藏。</p>
</li>
<li><p>使用after不会新增加标签，不回影响元素，是最流行的方法。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .<span class="property">clearfix</span>:：after&#123;<span class="comment">/*伪元素是行内元素 正常浏览器清除浮动方法*/</span></span><br><span class="line">        <span class="attr">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="attr">display</span>: table;</span><br><span class="line">        <span class="attr">clear</span>:both;</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="property">clearfix</span>&#123;</span><br><span class="line">        *<span class="attr">zoom</span>: <span class="number">1</span>;<span class="comment">/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fahter clearfix&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;big&quot;</span>&gt;</span>big<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;small&quot;</span>&gt;</span>small<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--&lt;div class=&quot;clear&quot;&gt;额外标签法&lt;/div&gt;--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-常见的行内元素和块级元素"><a href="#10-常见的行内元素和块级元素" class="headerlink" title="10. 常见的行内元素和块级元素"></a>10. 常见的行内元素和块级元素</h3><p>行内元素 inline</p>
<ul>
<li>span、input、img、textarea、label、select</li>
<li>不能设置宽高，多个元素共享一行，占满的时候会换行</li>
</ul>
<p> 块级元素block</p>
<ul>
<li>p、h1&#x2F;h2&#x2F;h3&#x2F;h4&#x2F;h5、div、ul、li、table</li>
<li>可以设置宽高，一个元素占满一整行</li>
</ul>
<p>inline-block</p>
<ul>
<li>可以设置宽高，多个元素共享一行，占满的时候会换行</li>
</ul>
<p>display</p>
<h3 id="11-px-em-rem-vw-vh-rpx等单位的特性"><a href="#11-px-em-rem-vw-vh-rpx等单位的特性" class="headerlink" title="11. px,em,rem,vw,vh,rpx等单位的特性"></a>11. px,em,rem,vw,vh,rpx等单位的特性</h3><p>px:像素</p>
<p>em:当前元素的字体大小</p>
<p>rem:根元素字体大小</p>
<p>vw:相对于视窗的宽度，视窗宽度是100vw</p>
<p>vh:相对于视窗的高度，视窗高度是100vh</p>
<p>rem单位翻译为像素值的时候是由html元素的字体大小决定的。此字体大小会被浏览器中字体大小的设置影响，除非显式的在html为font-size重写一个单位。</p>
<p>2.em单位转换为像素值的时候，取决于使用它们的元素的font-size的大小，但是有因为有继承关系，所以比较复杂。</p>
<h3 id="12-什么是DOM事件流？什么是事件委托-查"><a href="#12-什么是DOM事件流？什么是事件委托-查" class="headerlink" title="12. 什么是DOM事件流？什么是事件委托(查)"></a>12. <strong>什么是DOM事件流？什么是事件委托</strong>(查)</h3><ul>
<li>DOM事件流:事件发生时会在元素节点之间按照特定的顺序进行传播<ul>
<li>​	捕获阶段：最顶层节点开始，向下传播到目标元素接受的过程</li>
<li>​	目标阶段</li>
<li>​	冒泡阶段：目标元素接受然后逐级的向上传播</li>
</ul>
</li>
<li>在addeventListener()的第三个参数(useCapture)设为true，就会在捕获阶段运行，默认是false冒泡</li>
<li>事件委托:<ul>
<li>利用冒泡原理（子向父一层层穿透），把事件绑定到父元素中，以实现事件委托</li>
</ul>
</li>
</ul>
<h3 id="13-事件冒泡和事件捕捉有什么区别（查）"><a href="#13-事件冒泡和事件捕捉有什么区别（查）" class="headerlink" title="13. 事件冒泡和事件捕捉有什么区别（查）"></a>13. 事件冒泡和事件捕捉有什么区别（查）</h3><ul>
<li>事件冒泡<ul>
<li>在<code>addEventListener</code>中的第三属性设置为false（默认）</li>
<li>从下至上（儿子至祖宗）执行</li>
<li>阻止事件冒泡：<ul>
<li>e.stopPropagation</li>
</ul>
</li>
</ul>
</li>
<li>事件捕捉<ul>
<li>在<code>addEventListener</code>中的第三属性设置为true</li>
<li>从上至下（祖宗到儿子）执行</li>
</ul>
</li>
</ul>
<h3 id="14-link和-import"><a href="#14-link和-import" class="headerlink" title="14. link和@import"></a>14. link和@import</h3><p>1、从属关系：link是html的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等；而@import是css的语法，只有导入样式表的作用。</p>
<p>2、加载顺序：页面被加载时，link会和html同时被加载而；@import引入的 CSS 将在页面加载完毕后被加载。</p>
<p>3、兼容性：@import是 CSS2.1 才有的语法，所以只能在 IE5以上 才能识别；而link是 HTML 标签，所以不存在兼容性问题。</p>
<p>4、DOM：javascript只能控制dom去改变link标签引入的样式，而@import的样式不是dom可以控制的。</p>
<p>5、link方式的样式权重高于@import的权重</p>
<h3 id="15-响应式布局"><a href="#15-响应式布局" class="headerlink" title="15. 响应式布局"></a>15. 响应式布局</h3><p>响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局。。</p>
<ol>
<li>媒体查询：可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</li>
<li>rem布局：默认情况下我们html标签的<code>font-size</code>为16px,我们利用媒体查询，设置在不同设备下的字体大小。</li>
<li>如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可。</li>
</ol>
<h3 id="16-元素不可见"><a href="#16-元素不可见" class="headerlink" title="16. 元素不可见"></a>16. 元素不可见</h3><p><strong>display:none</strong></p>
<ul>
<li>该元素和他的子元素不会被渲染</li>
<li>会让元素从DOM消失，渲染的时候不占据任何空间</li>
</ul>
<p><strong>visibility:hidden</strong></p>
<ul>
<li>隐藏元素而不更改文档的布局</li>
<li>不会让元素从DOM消失，渲染的时候任然占据原来的空间</li>
</ul>
<p><strong>opacity:0</strong></p>
<ul>
<li>元素完全透明</li>
<li>不会让元素从DOM消失，渲染的时候任然占据原来的空间</li>
</ul>
<h3 id="17-css动画属性"><a href="#17-css动画属性" class="headerlink" title="17. css动画属性"></a>17. css动画属性</h3><ul>
<li><h4 id="transform-translate-参数1，参数2-———位移属性"><a href="#transform-translate-参数1，参数2-———位移属性" class="headerlink" title="transform:translate(参数1，参数2)———位移属性"></a>transform:translate(参数1，参数2)———位移属性</h4></li>
<li><h4 id="transform-scale-———-2D缩放"><a href="#transform-scale-———-2D缩放" class="headerlink" title="transform:scale()———-2D缩放"></a>transform:<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=scale&spm=1001.2101.3001.7020">scale</a>()———-2D缩放</h4></li>
<li><h4 id="transform-rotate-———2D旋转"><a href="#transform-rotate-———2D旋转" class="headerlink" title="transform:rotate()———2D旋转"></a>transform:rotate()———2D旋转</h4></li>
<li><p>@keyframes 关键帧名称{<br>  from{初始状态属性}<br>  to{结束状态属性}}</p>
</li>
</ul>
<h4 id="animation属性"><a href="#animation属性" class="headerlink" title="animation属性"></a>animation属性</h4><ul>
<li><h4 id="animation-name"><a href="#animation-name" class="headerlink" title="animation-name"></a>animation-name</h4></li>
</ul>
<p>所应用的动画名称（关键帧名称），必须配合@keyframes使用。</p>
<ul>
<li><h4 id="animation-duration"><a href="#animation-duration" class="headerlink" title="animation-duration"></a>animation-duration</h4></li>
</ul>
<p>动画持续的时间，例：animation-duration:3s; 即为动画的持续时间为3s。</p>
<ul>
<li><h4 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h4></li>
</ul>
<p> 动画的运动状态：<br>linear：匀速。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)<br>ease：平滑。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)<br>ease-in：由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)<br>ease-out：由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0)<br>ease-in-out：由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) </p>
<ul>
<li><h4 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h4></li>
</ul>
<p> 动画的循坏次数：<br>infinite： 无限循环<br>number: 循环的次数 </p>
<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h3 id="0-Object常用的API"><a href="#0-Object常用的API" class="headerlink" title="0. Object常用的API"></a>0. Object常用的API</h3><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">isHuman</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">printIntroduction</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>. Am I human? <span class="subst">$&#123;<span class="variable language_">this</span>.isHuman&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br></pre></td></tr></table></figure>

<p>Object.is()方法判断两个值是否为<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness">同一个值</a>。</p>
<p> Object.hasOwnProperty()方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）</p>
<p><code>**Object.assign()**</code> 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p>
<p><code>**Object.values()**</code>方法返回一个给定对象自身的所有可枚举value的数组</p>
<h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a>1. 基本数据类型</h3><p> <code>Undefined</code> 、 <code>Null</code> 、 <code>Boolean</code> 、 <code>Number</code> 、 <code>String</code>  、 <code>Symbol</code> 、 <code>BigInt</code></p>
<ul>
<li>Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。</li>
<li>BigInt 可以表示任意大小的整数。处理转换当中的精度缺失，它提供了一种方法来表示大于 <code>2^53 - 1</code> 的整数，在最后加n定义</li>
</ul>
<h3 id="2-数据类型检测"><a href="#2-数据类型检测" class="headerlink" title="2. 数据类型检测"></a>2. 数据类型检测</h3><table>
<thead>
<tr>
<th>不同类型</th>
<th><code>typeof</code></th>
<th><code>instanceof</code></th>
<th><code>Object.prototype.toString.call()</code></th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>快速区分基本类型</td>
<td>能够区分Array、Object和Function，原理：查找目标对象的原型链</td>
<td>精准判断数据类型</td>
</tr>
<tr>
<td>缺点</td>
<td>不能将Object、Array和Null区分，都返回object</td>
<td>Number，Boolean，String基本数据类型不能判断</td>
<td>写法繁琐不容易记，推荐进行封装后使用</td>
</tr>
</tbody></table>
<p>constructor:返回创建实例对象的构造函数的引用</p>
<p>如何判断变量是否为数组？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr); <span class="comment">// true</span></span><br><span class="line">arr.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr); <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>判断一个数是整数：</p>
<p>Number.isInteger，取余</p>
<p>类数组转换为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br></pre></td></tr></table></figure>

<p>array &#x3D; Array.from(arr);</p>
<h3 id="数据类型转换："><a href="#数据类型转换：" class="headerlink" title="数据类型转换："></a>数据类型转换：</h3><p><strong>强制转换</strong></p>
<ul>
<li>Number()</li>
<li>parseInt()</li>
<li>String()和toString()</li>
<li>Boolean()</li>
</ul>
<p><strong>自动转换</strong></p>
<ul>
<li>比较运算</li>
<li>算术运算</li>
</ul>
<h3 id="4-作用域和作用域链"><a href="#4-作用域和作用域链" class="headerlink" title="4. 作用域和作用域链"></a>4. 作用域和作用域链</h3><p>作用域：规定变量和函数的可适用范围称作用域，分为全局作用域和局部作用域</p>
<ul>
<li>全局作用域为程序的最外层作用域，一直存在</li>
<li>函数作用域只有函数被定义时才会创建，包含在父级函数作用域 &#x2F; 全局作用域内。</li>
<li>由于作用域的限制，每段独立的执行代码块只能访问自己作用域和外层作用域中的变量，无法访问到内层作用域的变量。</li>
</ul>
<p>作用域链：当可执行代码内部访问变量时，会先查找本地作用域，如果找到目标变量即返回，否则会去父级作用域继续查找…一直找到全局作用域。我们把这种作用域的嵌套机制，称为作用域链。</p>
<h3 id="5-什么是闭包"><a href="#5-什么是闭包" class="headerlink" title="5. 什么是闭包"></a>5. 什么是闭包</h3><p>闭包是指嵌套在一个函数内部中的函数。当一个嵌套的子函数引用了外部复函数的变量时，就产生了闭包。</p>
<p>原理：当前作用域可以访问上级作用域中的变量</p>
<p>作用：</p>
<p>（1）保护：<br> （2）保存：当前上下文的某些内容被上下文以外的内容占用，当前上下文不被释放，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来</p>
<p>优点和缺点：延长局部变量的生命周期，但会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p>
<p><strong>应用：</strong>setTimeout，柯里化(是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。)，模仿块级作用域，函数防抖和节流</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="title function_">create</span>();</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">200</span>;</span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决办法：在退出函数之前，将不使用的局部变量全部删除。</p>
<h3 id="6-this的指向"><a href="#6-this的指向" class="headerlink" title="6. this的指向"></a>6. this的指向</h3><ul>
<li>this 总是（非严格模式下）指向一个对象，而具体指向哪个对象是在运行时基于函数的<code>执行环境</code>动态绑定的，而非函数被声明时的环境；</li>
<li>this 在严格模式下 指向 undefined</li>
<li>this存在的环境有三种，全局执行上下文和函数执行上下文，eval。</li>
</ul>
<p><strong>1、作为对象的方法调用</strong></p>
<p>当函数作为对象的方法被调用时，<code>this指向该对象</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;yuguang&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === obj);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">getName</span>(); <span class="comment">// true yuguang</span></span><br></pre></td></tr></table></figure>

<p><strong>2、作为普通函数调用</strong></p>
<p>this总是指向全局对象（在浏览器中，通常是Window对象）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;老王&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;yuguang&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNew = obj.<span class="property">getName</span>;</span><br><span class="line"><span class="title function_">getNew</span>(); <span class="comment">// 老王</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3、构造器调用</strong></p>
<p>当new运算符调用函数时，总是返回一个对象，this通常也指向这个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyClass</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;yuguang&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">obj.<span class="property">name</span>; <span class="comment">// yuguang</span></span><br></pre></td></tr></table></figure>

<p>但是，如果显式的返回了一个object对象，那么此次运算结果最终会返回这个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyClass</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myClass = <span class="keyword">new</span> <span class="title class_">MyClass</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myClass:&#x27;</span>, myClass); <span class="comment">// &#123; name: 2&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>4、call或apply调用</strong></p>
<p>跟普通的函数调用相比，用call和apply可以动态的改变函数的this</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params">num = <span class="string">&#x27;&#x27;</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可以理解成在 obj2的作用域下调用了 obj1.getName()函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="title function_">getName</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">getName</span>.<span class="title function_">call</span>(obj2, <span class="number">2</span>)); <span class="comment">// 2 + 2 = 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">getName</span>.<span class="title function_">apply</span>(obj2, [<span class="number">2</span>])); <span class="comment">// 2 + 2 = 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>5.箭头函数</strong></p>
<p>箭头函数不会创建自己的this，它只会从自己的父类执行上下文继承this。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">val</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">val</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">getVal</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">getVal</span>(); <span class="comment">// 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-new-实现"><a href="#7-new-实现" class="headerlink" title="7. new 实现"></a>7. new 实现</h3><ol>
<li><p>首先创一个新的空对象。</p>
</li>
<li><p>根据原型链，设置空对象的 <code>__proto__</code> 为构造函数的 <code>prototype</code> 。</p>
</li>
<li><p>构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。</p>
</li>
<li><p>判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。</p>
</li>
<li><pre><code class="javascript">function createPerson(name,age)&#123;
    // 1.实例化Object对象
    const o=new Object()
    // 2.改变构造函数的this指向
    Person.call(o,name,age)
    // 3.原型链继承
    o.__proto__=Person.prototype
    // 4.返回这个对象
    return o
  &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">   创建一个空对象</span><br><span class="line">   </span><br><span class="line">   `object.create(null)`</span><br><span class="line"></span><br><span class="line">### 8. **0.1+0.2&gt;0.3** </span><br><span class="line"></span><br><span class="line">因为在JS底层中，每个变量是以二进制表示，固定长度为64位，其中第1位是符号位，再往后11位是指数为，最后52表示的是尾数位，而0.1和0.2转为二进制的时候是无限循环小数，所以JS就会进行截取，截取以后0.1和0.2就不是他们本身了，要比原来大那么一丢丢，所以0.1+0.2就&gt;0.3了</span><br><span class="line"></span><br><span class="line">解决：先给他们**放大倍数**，随后在**除以相应倍数**</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">const a = 0.1;</span><br><span class="line">const b = 0.2;</span><br><span class="line"></span><br><span class="line">console.log(a + b === 0.3)   // false</span><br><span class="line">console.log((a * 1000 + b * 1000) / 1000 === 0.3)  // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h3 id="9-和-的区别"><a href="#9-和-的区别" class="headerlink" title="9. &#x3D;&#x3D; 和&#x3D;&#x3D;&#x3D;的区别"></a>9. &#x3D;&#x3D; 和&#x3D;&#x3D;&#x3D;的区别</h3><p>&#x3D;&#x3D;&#x3D;是严格意义上的相等，会比较两边的数据类型和值大小</p>
<p>&#x3D;&#x3D;是非严格意义上的相等</p>
<p>Null &#x3D;&#x3D; Undefined -&gt;true<br>String &#x3D;&#x3D; Number -&gt;先将String转为Number，在比较大小<br>Boolean &#x3D;&#x3D; Number -&gt;现将Boolean转为Number，在进行比较<br>Object &#x3D;&#x3D; String，Number，Symbol -&gt; Object 转化为原始类型</p>
<h3 id="10-NaN-NaN返回什么"><a href="#10-NaN-NaN返回什么" class="headerlink" title="10. NaN === NaN返回什么"></a>10. <strong><code>NaN === NaN</code>返回什么</strong></h3><p>返回 <code>false</code>，<code>NaN</code>永远不等于<code>NaN</code>，判断是否为<code>NaN</code>用一个函数 <code>isNaN</code>来判断；</p>
<p><code>isNaN</code>传入的如果是其他数据类型，那么现将它使用<code>Number()</code>转为数字类型在进行判断</p>
<h3 id="11-手写call、apply、bind（查）"><a href="#11-手写call、apply、bind（查）" class="headerlink" title="11. 手写call、apply、bind（查）"></a>11. <strong>手写call、apply、bind</strong>（查）</h3><p>三者都是改变this的指向的方法，</p>
<p>判断是否是函数，call和apply都会调用函数，改变函数内部this的指向。</p>
<p>call和apply传递的参数不一样</p>
<p>call:</p>
<ul>
<li>如果不传参数，或者第一个参数是<code>null</code>或<code>nudefined</code>，<code>this</code>都指向<code>window</code></li>
<li>第一个参数是谁，this就指向谁，包括null和undefined，如果不传参数this就是undefined</li>
</ul>
<p>apply:</p>
<ul>
<li>apply把需要传递给fn的参数放到一个数组（或者类数组）中传递进去，虽然写的是一个数组，但是也相当于给fn一个个的传递</li>
</ul>
<p>bind:改变函数内部的this指向，函数不会被调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 先判断调用myCall是不是一个函数</span></span><br><span class="line">  <span class="comment">// 这里的this就是调用myCall的</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Not a Function&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不传参数默认为window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存this</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存参数</span></span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>).<span class="title function_">slice</span>(<span class="number">1</span>)   <span class="comment">//Array.from 把伪数组对象转为数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  <span class="keyword">let</span> result = context.<span class="title function_">fn</span>(...args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断this是不是函数</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Not a Function&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> result</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 默认是window</span></span><br><span class="line">      context = context || <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 保存this</span></span><br><span class="line">      context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否传参</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">        result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = context.<span class="title function_">fn</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>)&#123;</span><br><span class="line">  <span class="comment">// 判断是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Not a Function&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存调用bind的函数</span></span><br><span class="line">  <span class="keyword">const</span> _this = <span class="variable language_">this</span> </span><br><span class="line">  <span class="comment">// 保存参数</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>,<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">F</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 判断是不是new出来的</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="comment">// 如果是new出来的</span></span><br><span class="line">      <span class="comment">// 返回一个空对象，且使创建出来的实例的__proto__指向_this的prototype，且完成函数柯里化</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">_this</span>(...args,...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 如果不是new出来的改变this指向，且完成函数柯里化</span></span><br><span class="line">      <span class="keyword">return</span> _this.<span class="title function_">apply</span>(context,args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="12-执行栈和执行上下文"><a href="#12-执行栈和执行上下文" class="headerlink" title="12. 执行栈和执行上下文"></a>12. 执行栈和执行上下文</h3><p>执行栈：</p>
<ul>
<li>首先栈特点：先进后出</li>
<li>每次函数调用时，就会创建出它的执行上下文，然后进行压栈，当函数执行完成时，它的执行上下文就会被销毁，进行弹栈。</li>
<li>栈底永远是全局环境的执行上下文，栈顶永远是正在执行函数的执行上下文</li>
<li>只有浏览器关闭的时候全局执行上下文才会弹出</li>
</ul>
<p>执行上下文：</p>
<ul>
<li>全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。</li>
<li>函数执行上下文：每次函数调用时，都会新创建一个函数执行上下文</li>
</ul>
<h3 id="13-原型，原型链"><a href="#13-原型，原型链" class="headerlink" title="13. 原型，原型链"></a>13. 原型，原型链</h3><p>每个实例对象上都有一个 <code>__proto__ </code>隐式原型属性,每个构造函数都有一个<code>prototype</code>显示原型属性，两者都指向了构造函数的原型对象上。原型对象上的方法和属性能够被实例对象所共享。而原型对象上也是一个对象，他也有自己的原型。就这样一层一层的往上，直到Object的原型对象上的__proto__为null，就这样一层一层的链条形成了原型链。这也就是为什么每个对象都能够使用Object.prototype.tostring的方法</p>
<h3 id="14-JS-中的常用的继承方式"><a href="#14-JS-中的常用的继承方式" class="headerlink" title="14. JS 中的常用的继承方式"></a>14. <strong>JS 中的常用的继承方式</strong></h3><p>原型继承、构造函数继承、组合继承，寄生组合继承、ES6的extend</p>
<p>原型继承：会共享引用属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// ----------------------方法一：原型继承</span></span><br><span class="line">   <span class="comment">// 原型继承</span></span><br><span class="line">   <span class="comment">// 把父类的实例作为子类的原型</span></span><br><span class="line">   <span class="comment">// 缺点：子类的实例共享了父类构造函数的引用属性 </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name || <span class="string">&#x27;unknow&#x27;</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span> = age || <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name</span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">score</span> = <span class="number">80</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;lucy&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">name</span>);  <span class="comment">//lucy  --子类覆盖父类的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">age</span>);   <span class="comment">// 0    --父类的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">score</span>);  <span class="comment">// 80   --子类自己的属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>构造函数继承：会独享所有属性，包括引用属性（重点是函数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">hobbies</span> = [<span class="string">&#x27;music&#x27;</span>,<span class="string">&#x27;reading&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">stu1.<span class="property">hobbies</span>.<span class="title function_">push</span>(<span class="string">&#x27;basketball&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu1.<span class="property">hobbies</span>);  <span class="comment">// [&quot;music&quot;, &quot;reading&quot;, &quot;basketball&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu2.<span class="property">hobbies</span>);  <span class="comment">//  [&quot;music&quot;, &quot;reading&quot;]</span></span><br></pre></td></tr></table></figure>

<p>组合继承：利用原型链继承要共享的属性，利用构造函数继承要独享的属性，实现相对完美的继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------方法二：组合继承</span></span><br><span class="line"><span class="comment">// 在子函数中运行父函数，但是要利用call把this改变一下，</span></span><br><span class="line"><span class="comment">// 再在子函数的prototype里面new Father() ,使Father的原型中的方法也得到继承，最后改变Son的原型中的constructor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺点：调用了两次父类的构造函数，造成了不必要的消耗，父类方法可以复用</span></span><br><span class="line"><span class="comment">// 优点可传参，不共享父类引用属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = [<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;足球&quot;</span>, <span class="string">&quot;乒乓球&quot;</span>]</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>()</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Son</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;ming&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>寄生组合继承：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------方法三：寄生组合继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = [<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;足球&quot;</span>, <span class="string">&quot;乒乓球&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Son</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;ming&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>extend：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------方法四：ES6的extend（寄生组合继承的语法糖）</span></span><br><span class="line"><span class="comment">//     子类只要继承父类，可以不写 constructor ，一旦写了，则在 constructor 中的第一句话</span></span><br><span class="line"><span class="comment">// 必须是 super 。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123; <span class="comment">// Son.prototype.__proto__ = Father.prototype</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="number">200</span>)  <span class="comment">// super(200) =&gt; Father.call(this,200)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="15-内存泄漏"><a href="#15-内存泄漏" class="headerlink" title="15. 内存泄漏"></a>15. 内存泄漏</h3><p>概念：内存泄露是指不再用的内存没有被及时释放出来，导致该段内存无法被使用就是内存泄漏（全局变量、闭包、DOM 元素的引用、定时器）</p>
<p>原因：内存泄漏指我们无法在通过js访问某个对象，而垃圾回收机制却认为该对象还在被引用，因此垃圾回收机制不会释放该对象，导致该块内存永远无法使用，积少成多，系统会越来越卡以至于崩溃</p>
<p>解决：避免使用全局变量，手动删除定时器和DOM,removeEventListener移除事件监听。</p>
<h3 id="16-垃圾回收机制："><a href="#16-垃圾回收机制：" class="headerlink" title="16. 垃圾回收机制："></a>16. 垃圾回收机制：</h3><ul>
<li>标记清除法</li>
</ul>
<p>垃圾回收机制获取根节点并标记他们，然后访问并标记所有来自它们的引用，然后在访问这些对象并标记它们的引用…如此递进结束后若发现有没有标记的（不可达的）进行删除，进入执行环境的不能进行删除</p>
<ul>
<li>引用计数法</li>
</ul>
<p>当声明一个变量并赋值时，值+1，当该值被取代时-1，为0时进行删除。</p>
<h3 id="17-深拷贝和浅拷贝"><a href="#17-深拷贝和浅拷贝" class="headerlink" title="17. 深拷贝和浅拷贝"></a>17. 深拷贝和浅拷贝</h3><p>浅拷贝：创建了一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，则拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<ol>
<li><strong>Object.assign() 方法：</strong> 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</li>
<li><strong>Array.prototype.slice()：</strong>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</li>
<li><strong>拓展运算符<code>...</code></strong></li>
</ol>
<p>深拷贝：拷贝所有的属性，并在计算机中开辟出了一块新的内存，拷贝前后两个对象互不影响。</p>
<p>js实用工具库，提供了许多API</p>
<ul>
<li>Lodash中的_.cloneDeep()，_.merge(a,b)(合并)，_.reject()（根据条件去除某个元素）</li>
<li>手写循环递归</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = <span class="title function_">clone</span>(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>JSON.parse(JSON.stringify())</li>
</ul>
<p>缺点：NaN &#x3D;&#x3D;&#x3D;&gt; null</p>
<p>​			undefined 函数 &#x3D;&#x3D;&#x3D;&gt; 丢失</p>
<p>​			时间戳 &#x3D;&#x3D;&#x3D;&gt; 字符串时间</p>
<p>​			错误信息 &#x3D;&#x3D;&#x3D;&gt; 空对象</p>
<p>​			循环引用对象 &#x3D;&#x3D;&#x3D;》 报错</p>
<p>​			obj中有属性是new出来的，则会丢弃对应的constructor 初始化构造器</p>
<h3 id="18-js是单线程"><a href="#18-js是单线程" class="headerlink" title="18. js是单线程"></a>18. js是单线程</h3><p>因为JS里面有可视的Dom，如果是多线程的话，这个线程正在删除DOM节点，另一个线程正在编辑Dom节点，导致浏览器不知道该听谁的。</p>
<h3 id="19-promise"><a href="#19-promise" class="headerlink" title="19. promise"></a>19. promise</h3><p><code>promise</code>是异步编程的解决方案，简单来说就是一个容器，里面保存着一个异步操作的结果，从语法上说，<code>promise</code>是一个对象，可以改变对象获取异步操作的消息。promise共有三个状态</p>
<p>pending（执行中）、success（成功）、rejected（失败）</p>
<p>状态只能由 Pending –&gt; Fulfilled 或者 Pending –&gt; Rejected，且一但发生改变便不可二次修改</p>
<p>作用：他可以解决回调地狱的问题，也就是异步深层嵌套的问题。</p>
<p>基本使用：我们可以new一个promise  <code>promise</code>的构造函数接受一个函数，并且传入两个参数：<code>resolve</code>和<code>reject</code>分别表示异步操作执行成功的回调和失败的回调。<code>promise</code>实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数。</p>
<p>.catch()：获取异常信息</p>
<p>.all()：Promise.all()创建的Promise会在这一组Promise全部解决后在解决。也就是说会等待所有的promise程序都返回结果之后执行后续的程序。返回一个新的Promise。应用：当需要加载的资源较多时。</p>
<ul>
<li>如果所有都成功，则合成Promise的返回值就是所有子Promise的返回值数组。</li>
<li>如果有一个失败，那么第一个失败的会把自己的理由作为合成Promise的失败理由</li>
</ul>
<p>.race()：得到的却是数组中跑的最快的那个，当最快的一跑完就立马结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">		//做一些异步操作</span><br><span class="line">		setTimeout(function()&#123;</span><br><span class="line">			var flag = false</span><br><span class="line">			if(flag) &#123;</span><br><span class="line">			resolve(&#x27;hello&#x27;)</span><br><span class="line">			&#125;	else &#123;</span><br><span class="line">				reject(&#x27;出错了&#x27;)</span><br><span class="line">					&#125;</span><br><span class="line">		&#125;, 2000);</span><br><span class="line">	&#125;);</span><br><span class="line">	p.then(function(data) &#123;</span><br><span class="line">	console.log(&#x27;成功回调&#x27;,data)</span><br><span class="line">	&#125;,function(info) &#123;</span><br><span class="line">	console.log(&#x27;失败了&#x27;,info))</span><br></pre></td></tr></table></figure>

<p>通过promise获取网络图片</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>手写promise加载图片<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">const</span> url1=<span class="string">&#x27;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3719520752,2657134858&amp;fm=26&amp;gp=0.jpg&#x27;</span><span class="comment">//网上随便找一个图片的地址</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">const</span> url2=<span class="string">&#x27;https://dss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3461776228,1302027451&amp;fm=26&amp;gp=0.jpg&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">function</span> <span class="title function_">loadImage</span>(<span class="params">src</span>)&#123;<span class="comment">//定义一个异步加载图片的函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="comment">//new一个promise对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			<span class="keyword">const</span> img =<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>)<span class="comment">//创建一个img节点</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			img.<span class="property">src</span>=src<span class="comment">//把我们的图片地址给我们新建的节点</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			img.<span class="property">onload</span>=<span class="function">()=&gt;</span>&#123;<span class="comment">//通过监听节点成功建立（当然图片也传进去）调用resolve</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">				<span class="title function_">resolve</span>(img)<span class="comment">//返回整个节点,可以用.then捕捉</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			img.<span class="property">onerror</span>=<span class="function">()=&gt;</span>&#123;<span class="comment">//监听错误，可以用.catch捕捉</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">				<span class="title function_">reject</span>(<span class="string">`图片加载失败，地址为<span class="subst">$&#123;src&#125;</span>`</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		&#125;) </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="keyword">return</span> p<span class="comment">//记得把整个promise对象返回</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="title function_">loadImage</span>(url1)<span class="comment">//调用异步函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="20-async和await"><a href="#20-async和await" class="headerlink" title="20. async和await"></a>20. async和await</h3><p>作用：async用于申明一个function是异步的，而await用于等待一个异步方法执行完成，他可以很好的替代promise中的then。</p>
<p>async函数返回一个promise对象，当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，在接着执行函数体内后面的语句</p>
<h3 id="21-宏任务和微任务"><a href="#21-宏任务和微任务" class="headerlink" title="21. 宏任务和微任务"></a>21. 宏任务和微任务</h3><ul>
<li>宏任务：script,setTimeOut<code>、</code>setInterval,DOM事件</li>
<li>微任务：promise.then<code>,</code>process.nextTick<code>、</code>MutationObserver</li>
<li>微任务比宏任务先执行</li>
<li>promise的resolve是同步的，async遇到await之前是同步的，在执行await后面的代码，返回promise,await下面的代码放入微任务并退出。</li>
</ul>
<h3 id="22-js执行机制-event-loop-事件循环"><a href="#22-js执行机制-event-loop-事件循环" class="headerlink" title="22. js执行机制(event loop 事件循环)"></a>22. js执行机制(event loop 事件循环)</h3><p>JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。</p>
<p>1）所有的同步任务都在主线程上执行，行成一个执行栈。</p>
<p>2）除了主线程之外，还存在一个任务列队event table，只要异步任务有了运行结果，Event Table会将这个函数移入Event Queue。</p>
<p>3）但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行宏任务中的微任务，将微任务放入eventqueue，但是两个queue不同。</p>
<p>4）主线程执行完毕后，会去微任务queue中读取，进入主线程执行，再从宏任务的queue读取。</p>
<p>5）重复上面三步。</p>
<h3 id="24-防抖和节流"><a href="#24-防抖和节流" class="headerlink" title="24. 防抖和节流"></a>24. 防抖和节流</h3><p>防抖：n秒后在执行该事件，若在n秒内被重复触发，则重新计时（频繁操作点赞和取消点赞，搜索联想，）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce2</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> timer</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> callNow = !timer</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">        <span class="keyword">if</span> (callNow) &#123; <span class="title function_">fn</span>(args) &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>节流：n秒内只运行一次，若在n秒内重复触发，只有一次生效（鼠标不断点击触发）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle2</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> timer</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">let</span> _this = <span class="variable language_">this</span></span><br><span class="line">       <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">       <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">         timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">           timer = <span class="literal">null</span></span><br><span class="line">           fn.<span class="title function_">apply</span>(_this, <span class="variable language_">arguments</span>)</span><br><span class="line">         &#125;, wait);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行</p>
<h3 id="26-常用的数组方法（查）"><a href="#26-常用的数组方法（查）" class="headerlink" title="26. 常用的数组方法（查）"></a>26. 常用的数组方法（查）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;李白&quot;</span>, <span class="number">123</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">true</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>]</span><br><span class="line">        <span class="comment">// 在数组末尾增加 push()</span></span><br><span class="line">        arr.<span class="title function_">push</span>(<span class="string">&quot;剑仙&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">        <span class="comment">// 在数组末尾删除 pop()</span></span><br><span class="line">        arr.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">        <span class="comment">// 在数组开头删除 shift()</span></span><br><span class="line">        arr.<span class="title function_">shift</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">        <span class="comment">// 删除 splice()</span></span><br><span class="line">        arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">        <span class="comment">// 修改 splice()</span></span><br><span class="line">        arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;诗圣&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">        arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组转化为字符串 join() 产生一个新数组，不会改变原数组 以xx隔开</span></span><br><span class="line">        <span class="keyword">var</span> arr1 = arr.<span class="title function_">join</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);</span><br><span class="line">        <span class="comment">// 合并两个数组 concat() 产生一个新数组，不会改变原数组</span></span><br><span class="line">        <span class="keyword">var</span> arr3 = arr.<span class="title function_">concat</span>(arr1)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr3);</span><br><span class="line">        <span class="comment">// 数组的截取 slice() 产生一个新数组，不会改变原数组</span></span><br><span class="line">        <span class="keyword">var</span> arr4 = arr.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr4);</span><br><span class="line">        <span class="comment">// 数组的翻转 reverse() 产生一个新数组，不会改变原数组</span></span><br><span class="line">        <span class="keyword">var</span> arr5 = arr.<span class="title function_">reverse</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr5);</span><br><span class="line">        <span class="comment">// 数组排序 sort() 产生一个新数组，不会改变原数组</span></span><br><span class="line">        <span class="keyword">var</span> arr6 = arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a - b</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr6);</span><br></pre></td></tr></table></figure>

<h4 id="1-数组排序"><a href="#1-数组排序" class="headerlink" title="1. 数组排序"></a>1. 数组排序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= arr.<span class="property">length</span> - i - <span class="number">1</span>; j++) &#123; </span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<h4 id="2-数组最大值"><a href="#2-数组最大值" class="headerlink" title="2. 数组最大值"></a>2. 数组最大值</h4><h5 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">343</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">65</span>, <span class="number">234</span>]</span><br><span class="line">        <span class="keyword">var</span> max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                max = a[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(max);</span><br></pre></td></tr></table></figure>

<h4 id="3-数组去重"><a href="#3-数组去重" class="headerlink" title="3. 数组去重"></a>3. 数组去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">54</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span> - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">                    arr.<span class="title function_">splice</span>(j, <span class="number">1</span>)</span><br><span class="line">                    j--  <span class="comment">// 因为每次删除都会改变数组的长度，所以删了之后要是下标-1,之后再+1回到原来下标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<h4 id="4-反转数组"><a href="#4-反转数组" class="headerlink" title="4. 反转数组"></a>4. 反转数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>, <span class="string">&#x27;hotpink&#x27;</span>];</span><br><span class="line">        <span class="keyword">var</span> newArr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            newArr[newArr.<span class="property">length</span>] = arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr);</span><br></pre></td></tr></table></figure>

<h4 id="5-遍历数组"><a href="#5-遍历数组" class="headerlink" title="5. 遍历数组"></a>5. 遍历数组</h4><h5 id="1-for-of"><a href="#1-for-of" class="headerlink" title="1. for of"></a><strong>1. for of</strong></h5><ul>
<li>不同于forEach的是，for of 循环可以随时退出</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>, <span class="string">&#x27;hotpink&#x27;</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">//red green blue pink purplr hotpink</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-forEach"><a href="#2-forEach" class="headerlink" title="2. forEach"></a><strong>2. forEach</strong></h5><ul>
<li>可以通过return跳出本次循环，执行下一次循环</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 1 2 4 5 6</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-some"><a href="#3-some" class="headerlink" title="3. some"></a>3. some</h5><ul>
<li>不会对空数组进行检测</li>
<li>不会改变原数组</li>
<li>检测数组里的每一个值是否满足条件，如果有一个满足就返回true，否则返回false</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    <span class="keyword">const</span> result = arr.<span class="title function_">some</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 1 2 3</span></span><br><span class="line">      <span class="keyword">return</span> item === <span class="number">3</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="4-every"><a href="#4-every" class="headerlink" title="4. every"></a>4. every</h5><ul>
<li>不会对空数组进行检测</li>
<li>不会改变原数组</li>
<li>检测数组里的每一个值是否满足条件，如果有一个不满足就返回false，否则返回true</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    <span class="keyword">const</span> result = arr.<span class="title function_">every</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 1 </span></span><br><span class="line">      <span class="keyword">return</span> item === <span class="number">3</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="5-map"><a href="#5-map" class="headerlink" title="5. map"></a>5. map</h5><ul>
<li>不会对空数组进行检测</li>
<li>不会改变原数组</li>
<li>按照原始数组元素顺序依次处理，返回一个新数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">   <span class="keyword">const</span> result = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 1 2 3 4 5 6 </span></span><br><span class="line">     <span class="keyword">return</span> item * item</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// [1 4 9 16 25 36]</span></span><br></pre></td></tr></table></figure>

<h5 id="6-filter"><a href="#6-filter" class="headerlink" title="6. filter"></a>6. filter</h5><ul>
<li>不会对空数组进行检测</li>
<li>不会改变原数组</li>
<li>对数组进行渲染，返回符合条件的数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">   <span class="keyword">const</span> result = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 1 2 3 4 5 6</span></span><br><span class="line">     <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// [4,5,6]</span></span><br></pre></td></tr></table></figure>

<h5 id="7-find"><a href="#7-find" class="headerlink" title="7. find()"></a>7. find()</h5><ul>
<li><p>不会对空数组进行检测</p>
</li>
<li><p>不会改变原数组</p>
</li>
<li><p>找到符合条件的第一项，没有找到返回undefined</p>
</li>
<li><pre><code class="js">var arr = [1, 2, 3, 4, 5, 6]
    const result = arr.find((item) =&gt; &#123;
      console.log(item) // 1 2 3 4 5 6
      return item &gt; 3
    &#125;)
    console.log(result) // 4
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 27. 常用的字符串方法（查）</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line"> 		// 字符串的长度                length</span><br><span class="line">        console.log(str1.length)</span><br><span class="line">        // 通过下标获取某个字符       str.charAt()</span><br><span class="line">        let str5 = &#x27;我是一个字符串&#x27;</span><br><span class="line">        console.log(str5.charAt(3))</span><br><span class="line">        // 截取字符串 str.slice()</span><br><span class="line">        console.log(str5.slice(2, 4))</span><br><span class="line"></span><br><span class="line">        // 返回字符串第一次出现的位置  没有出现过返回-1 str.indexOf()</span><br><span class="line">        console.log(str5.indexOf(&#x27;123&#x27;))</span><br><span class="line">        console.log(str5.search(&#x27;个&#x27;))</span><br><span class="line">        // indexOf和search的区别    indexOf只能匹配字符串</span><br><span class="line">        // search可以匹配 正则和字符串</span><br><span class="line">        </span><br><span class="line">        // 替换字符串                  str.replace()</span><br><span class="line">        let str6 = &#x27;sldjfsljflskjfdslfjdsl&#x27;</span><br><span class="line">        let str7 = str6.replace(&#x27;s&#x27;, &#x27;我的&#x27;)</span><br><span class="line">        console.log(str7, str6)</span><br><span class="line"></span><br><span class="line">        // 分割字符串转化为数组          str.split()</span><br><span class="line">        console.log(str6.split(&#x27;s&#x27;))</span><br><span class="line"></span><br><span class="line">        // 表单里面比较重要的的      str.trim()</span><br><span class="line">        let str8 = &#x27; 我的字符 &#x27;</span><br><span class="line">        console.log(str8.length)</span><br><span class="line">        console.log(str8.trim().length)</span><br><span class="line"></span><br><span class="line">        // 判断字符串是否有某个字符  str.includes()</span><br><span class="line">        console.log(str8.includes(&#x27;我&#x27;))</span><br><span class="line">        // 多一嘴 数组也是一样的方法</span><br><span class="line">        let arr = [1, 2, 3, 45, 3, 1, &#x27;123&#x27;, 12]</span><br><span class="line">        console.log(arr.includes(123))</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="28-bom和dom的区别"><a href="#28-bom和dom的区别" class="headerlink" title="28. bom和dom的区别"></a>28. bom和dom的区别</h3><ul>
<li><p>bom就是window，包含windows（窗口）、navigator（浏览器）、screen（浏览器屏幕）、history（访问历史）、location（地址）等，浏览器相关的东西。bom是包含dom的。</p>
</li>
<li><p>dom是document， html相关的都在里面</p>
</li>
</ul>
<h3 id="29-JS性能优化的方式"><a href="#29-JS性能优化的方式" class="headerlink" title="29. JS性能优化的方式"></a>29. JS性能优化的方式</h3><ul>
<li>垃圾回收</li>
<li>防抖节流</li>
<li>分批加载（setInterval,加载10000个节点）</li>
<li>事件委托</li>
<li>requestAnimationFrame的使用</li>
<li>script标签中的defer和async</li>
<li>CDN（CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求）</li>
</ul>
<h3 id="30-defer-和-async"><a href="#30-defer-和-async" class="headerlink" title="30. defer 和 async"></a>30. defer 和 async</h3><ul>
<li><p>浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<script>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p>
<p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p>
</li>
<li><p>然后是 defer和 async；他们两个是异步加载 js 代码的。</p>
</li>
<li><p>defer，async</p>
<ul>
<li><p>渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p>
<p>defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<strong>defer是“渲染完再执行”，async是“下载完就执行”</strong>。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p>
</li>
</ul>
</li>
</ul>
<h3 id="31-set和map"><a href="#31-set和map" class="headerlink" title="31. set和map"></a>31. set和map</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，<strong>没有重复的值</strong>。通过 <em><strong>*add方法*</strong></em> 向 Set 结构加入成员，也可以利用set进行数组去重。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br></pre></td></tr></table></figure>

<p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，用作数据存储</p>
<h3 id="32-for-of和for-in"><a href="#32-for-of和for-in" class="headerlink" title="32. for of和for in"></a>32. for of和for in</h3><ul>
<li>for of 遍历数组</li>
<li>for in 遍历对象：遍历对象的key或者数组的下标，到原型链查找，遍历新增加的属性的key值，所以不能用于遍历数组。</li>
</ul>
<h3 id="25-js遍历数组的方法（查）"><a href="#25-js遍历数组的方法（查）" class="headerlink" title="25. js遍历数组的方法（查）"></a>25. js遍历数组的方法（查）</h3><ul>
<li><p><strong>for循环，也是最常见的</strong></p>
</li>
<li><pre><code class="js">var arr = [1, 2, 3, 4, 5, 6]
for(var i = 0; i &lt; arr.length; i++) &#123;
    console.log(arr[i])
&#125;
// 1 2 3 4 5 6
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **forEach( function(item,index,array)&#123;&#125;) //当前元素（必须），下标（可选），数组（可选）。** **没有返回值**</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    var arr = [1, 2, 3, 4, 5, 6]</span><br><span class="line">    arr.forEach((item, idnex, array) =&gt; &#123;</span><br><span class="line">        console.log(item)     // 1 2 3 4 5 6</span><br><span class="line">        console.log(array)    // [1, 2, 3, 4, 5, 6]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><strong>array.map(function(item, index, array){ }).//当前元素（必须），下标（可选），数组（可选）。</strong> <strong>有返回值</strong></p>
<ul>
<li><pre><code class="js">// 一、会改变原数组
var arr = [1, 2, 3, 4, 5, 6]
var newArr = arr.map(function (item, idnex) &#123;
    return item * item
&#125;)
console.log(arr)      // [1, 2, 3, 4, 5, 6]
console.log(newArr)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **filter**“过滤”、“筛选”, 对数组中的每一项运行给定函数，返回该函数会返回true的想项组成的新数组。指数组filter后，返回过滤后的新数组。</span><br><span class="line"></span><br><span class="line">  与map方法不同的是，filter方法的callback函数需要返回等于true值。如果为true，则通过，否则，不通过。不可以原数组。</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  var arr = [</span><br><span class="line">  	&#123; id: 1, name: &#x27;买笔&#x27;, done: true &#125;,</span><br><span class="line">  	&#123; id: 2, name: &#x27;买笔记本&#x27;, done: true &#125;,</span><br><span class="line">  	&#123; id: 3, name: &#x27;练字&#x27;, done: false &#125;</span><br><span class="line">  ]</span><br><span class="line">      </span><br><span class="line">  var newArr = arr.filter(function (item, index) &#123;</span><br><span class="line">  	return item.done</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(newArr)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>every()，some()</p>
</li>
<li><p>for of </p>
<ul>
<li><pre><code class="js">var arr = [&#39;我&#39;, &#39;是&#39;, &#39;谁&#39;, &#39;我&#39;, &#39;在&#39;, &#39;哪&#39;]
for(var key of arr) &#123;
    console.log(key)
&#125;
// 我 是 谁 我 在 哪
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### 33. 数组去重</span><br><span class="line"></span><br><span class="line">- **for循环嵌套，利用splice去重**</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">function newArr(arr)&#123;</span><br><span class="line">    for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        for(var j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">            if(arr[i]==arr[j])&#123; </span><br><span class="line">            //如果第一个等于第二个，splice方法删除第二个</span><br><span class="line">            arr.splice(j,1);</span><br><span class="line">            j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1,1,2,5,6,3,5,5,6,8,9,8];</span><br><span class="line">console.log(newArr(arr))</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>建新数组，利用indexOf去重</strong></p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newArr</span>(<span class="params">array</span>)&#123; </span><br><span class="line">    <span class="comment">//一个新的数组 </span></span><br><span class="line">    <span class="keyword">var</span> arrs = []; </span><br><span class="line">    <span class="comment">//遍历当前数组 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++)&#123; </span><br><span class="line">        <span class="comment">//如果临时数组里没有当前数组的当前值，则把当前值push到新数组里面 </span></span><br><span class="line">        <span class="keyword">if</span> (arrs.<span class="title function_">indexOf</span>(array[i]) == -<span class="number">1</span>)&#123; </span><br><span class="line">            arrs.<span class="title function_">push</span>(array[i])</span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> arrs; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">8</span>];</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">newArr</span>(arr))</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Set去重</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">newArr</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">newArr</span>(arr))</span><br></pre></td></tr></table></figure>

<h3 id="34-数组排序"><a href="#34-数组排序" class="headerlink" title="34. 数组排序"></a>34. 数组排序</h3><ul>
<li><strong>冒泡排序</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">52</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">57</span>,<span class="number">75</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> j =<span class="number">0</span>;j&lt;arr.<span class="property">length</span>-i; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">			<span class="keyword">var</span> temp = arr[j];</span><br><span class="line">			arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">			arr[j+<span class="number">1</span>]=temp; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">//[1, 2, 3, 8, 52, 57, 75]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sort<strong>排序</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort排序</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">8</span>,<span class="number">12</span>,<span class="number">312</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortArray</span>(<span class="params">n1,n2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> n1-n2;</span><br><span class="line">&#125;</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="title function_">sortArray</span>()); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">//[4, 5, 8, 12, 312]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>选择排序</strong></p>
</li>
<li><pre><code class="javascript">// 选择排序
var arr = [14, 82, 7, 1, 9, 0];
for(var i = 0; i &lt; arr.length - 1; i++)&#123;
    for(var j = i + 1; j &lt; arr.length; j++)&#123;
        if(arr[i] &gt; arr[j])&#123;
            var tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
        &#125;
    &#125;
 &#125;
console.log(arr);//[0, 1, 7, 9, 14, 82]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 35. 反转字符串</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">function reverseString(str) &#123;</span><br><span class="line">    return str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">reverseString(&#x27;hello&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseString</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> newString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = str.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        newString += str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newString;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">reverseString</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseString</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="title function_">reverseString</span>(str.<span class="title function_">substr</span>(<span class="number">1</span>)) + str.<span class="title function_">charAt</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">reverseString</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="35-什么是暂时性死区？"><a href="#35-什么是暂时性死区？" class="headerlink" title="35. 什么是暂时性死区？"></a>35. 什么是暂时性死区？</h3><p>暂时性死区是指，当进入一个作用域，我去使用一个变量名，而这个变量名已经存在了，但是是不可获取的，就会报错，造成暂时性死区问题；比如一个作用域下面使用了 let 定义了 <code>x</code>,但是在定义之前就使用了 <code>x</code>，就会报错；</p>
<h3 id="36-函数柯里化"><a href="#36-函数柯里化" class="headerlink" title="36. 函数柯里化"></a>36. 函数柯里化</h3><p>”函数柯里化”是指将多变量函数拆解为单变量的多个函数的依次调用， 可以从高元函数动态地生成批量的低元的函数。简单讲：就是利用函数执行，可以形成一个不销毁的私有作用域，把预先处理的内容都存在这个不销毁的作用域里面，并且返回一个函数，以后要执行的就是这个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规的add函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curryingAdd</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">y</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)           <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">curryingAdd</span>(<span class="number">1</span>)(<span class="number">2</span>)   <span class="comment">// 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="37-null与undefined的区别"><a href="#37-null与undefined的区别" class="headerlink" title="37. null与undefined的区别"></a>37. null与undefined的区别</h3><ul>
<li>null表示⼀个对象可以是null，代表是个空对象，⽽null本身也是对象。<ul>
<li>①用作函数的参数，表示该函数的参数不是对象。</li>
<li>②用作对象原型链的终点。</li>
</ul>
</li>
<li>undefined表示『不存在』，JavaScript是⼀⻔动态类型语⾔，成员除了表示存在的空值外，还有可能根本就不存在(因为存不存在只在运⾏期才知道)，这就是undefined的意义所在。<ul>
<li>①函数没有返回值时，默认返回undefined。</li>
<li>②变量已声明，没有赋值时，为undefined。</li>
<li>③对象中没有赋值的属性，该属性的值为undefined。</li>
<li>④调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>
</ul>
</li>
</ul>
<h3 id="38-new-String-a-和String-a"><a href="#38-new-String-a-和String-a" class="headerlink" title="38. new String('a')和String('a')"></a>38. new String('a')和String('a')</h3><ul>
<li>new String('a')：返回的是引用类型，在堆内进行存储，返回值是字符串对象；</li>
<li>String('a')：返回类型是基本类型，在栈内存储，返回的是字符串。</li>
</ul>
<h3 id="39-和-和！！操作符的返回值"><a href="#39-和-和！！操作符的返回值" class="headerlink" title="39. || 和 && 和！！操作符的返回值"></a>39. || 和 && 和！！操作符的返回值</h3><p>两者都会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后在执行条件判断</p>
<ul>
<li>对于||来说，如果条件判断结果为true就返回第一个操作数的值，如果为false就返回第二个操作数的值</li>
<li>&&则相反，如果条件判断结果为true就返回第二个操作数的值，如果为false就返回第一个操作数的值</li>
<li>!!运算符可以将右侧的值强制转换为布尔值，这也是将值转化为布尔值的方法之一</li>
</ul>
<h3 id="40-获取安全的undefined"><a href="#40-获取安全的undefined" class="headerlink" title="40.获取安全的undefined"></a>40.获取安全的undefined</h3><p>因为<code>undefined</code>是一个标识符，所以可以被当做变量来使用和赋值，但是这样会影响<code>undefined</code>的正常判断。</p>
<p>使用void 0来获得undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  a = <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><ol>
<li><p>新增symbol类型 表示独一无二的值，用来定义独一无二的对象属性名;</p>
</li>
<li><p>const/let  都是用来声明变量,不可重复声明，具有块级作用域。存在暂时性死区，也就是不存在变量提升。(const一般用于声明常量);</p>
</li>
<li><p>解构赋值, 可以将属性/值从对象/数组中取出，赋值给其他变量。这种语法是 ECMAscript 6 规范引入了一种新语法，可以更轻松地从数组和对象中获取值。</p>
</li>
<li><p>模板字符串(<code>$&#123;data&#125;</code>)</p>
</li>
</ol>
<ul>
<li>比如在处理嵌入表达式、多行字符串、字符串中插入变量、字符串格式化等方面的应用</li>
</ul>
<ol start="5">
<li>扩展运算符(数组、对象);</li>
</ol>
<ul>
<li><strong><code>对象中的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</code></strong></li>
<li>可以将数组转换为参数序列</li>
</ul>
<ol start="6">
<li><p>箭头函数;</p>
</li>
<li><p>Set和Map数据结构;</p>
</li>
</ol>
<ul>
<li>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，<strong>没有重复的值</strong>。通过 <em><strong>*add方法*</strong></em> 向 Set 结构加入成员，也可以利用set进行数组去重。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，用作数据存储</li>
</ul>
<ol start="8">
<li><p>Proxy/Reflect;</p>
</li>
<li><p>Promise;</p>
</li>
<li><p>async函数;</p>
</li>
<li><p>Class;</p>
</li>
<li><p>Module语法(import/export)。</p>
</li>
</ol>
<h3 id="1-export-和-export-default-有什么区别"><a href="#1-export-和-export-default-有什么区别" class="headerlink" title="1. export 和 export default 有什么区别"></a>1. export 和 export default 有什么区别</h3><ul>
<li><code>export</code> 是命名导出，每个模块可以命名导出多个。</li>
<li><code>export default</code> 是默认导出，每个模块只能默认导出一个。</li>
<li>使用<code>export</code>导出的使用 <code>import &#123;exportName&#125; from &#39;xxx&#39;</code>来导入。</li>
<li>使用<code>export default </code>导出的使用<code>import xx from &#39;xxx&#39;来导入</code></li>
<li>两者可以同时存在。</li>
</ul>
<h3 id="2-var-let-const区别"><a href="#2-var-let-const区别" class="headerlink" title="2. var/let/const区别"></a>2. var/let/const区别</h3><ul>
<li>var、let 定义的是变量，const 定义的是常量</li>
<li>var 存在变量提升，let const 不存在变量提升</li>
<li>let const 存在块级作用域</li>
<li>const 声明的常量，基本数据类型无法被修改，对象或者数组的可以修改内部的属性值</li>
<li>var 可以重复声明，let，const 在同一个块级作用域中重复声明会报语法错误</li>
<li>浏览器的全局对象是window，Node的全局对象是global。var 声明的变量为全局变量，并且会将改变量添加为全局对象的属性，但是let 和 const 不会。</li>
<li>在使用let const 命令声明变量之前，该变量都是不可用的。在这语法上，称为暂时性死区。使用 var 不会存在暂时性死区。</li>
<li>在变量声明时，let var 可以不用设置初始值。而 const 声明变量必须设置初始值。</li>
</ul>
<h3 id="3-箭头函数和普通函数的区别"><a href="#3-箭头函数和普通函数的区别" class="headerlink" title="3. 箭头函数和普通函数的区别"></a>3. 箭头函数和普通函数的区别</h3><ul>
<li>箭头函数没有自己的this，他会从自己的作用域链的上一层继承this(因此无法使用call / apply / bing 进行绑定this值)</li>
<li>箭头函数没有arguments对象，如果要用，可以用rest参数代替</li>
<li>不可以使用yield命令，因此箭头函数不能用作Generator 函数</li>
<li>不可以使用new 命令，因为没有自己的this 以及 prototype 属性</li>
</ul>
<h3 id="4-CommonJS模块和ES6模块"><a href="#4-CommonJS模块和ES6模块" class="headerlink" title="4. CommonJS模块和ES6模块"></a>4. CommonJS模块和ES6模块</h3><ul>
<li>CommonJS是对模块的浅拷贝，ES6 Module是对模块的引用，即ES6 Module只存不读，不能改变值，指针指向不能变。</li>
</ul>
<p>共同点：CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。  </p>
<h3 id="5-import-和-require-的区别"><a href="#5-import-和-require-的区别" class="headerlink" title="5. import 和 require 的区别"></a>5. import 和 require 的区别</h3><ul>
<li><strong>遵循规范</strong>：<code>require</code> 是 AMD(异步模块加载机制)，<code>import</code> 是ES6的一个语法标准，如果要兼容的话必须转化成ES5</li>
<li><strong>调用时间</strong>：<code>require</code>是运行时调用， 所以require理论上可以运用在代码的任何地方 ；<code>import</code>是编译时调用，所以必须放在文件开头。</li>
<li><strong>本质</strong>：<code>require</code> 是赋值过程， module.exports后面的内容是什么，require的结果就是什么，比如对象、数字、字符串、函数等，然后再把require的结果赋值给某个变量，它相当于module.exports的传送门 ；<code>import</code>是解构过程。</li>
</ul>
<h3 id="6-Object-defineproperty-和-Proxy"><a href="#6-Object-defineproperty-和-Proxy" class="headerlink" title="6.  Object.defineproperty 和 Proxy"></a>6.  Object.defineproperty 和 Proxy</h3><p> Object.defineproperty 是Vue2实现响应式的原理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数：劫持对象，对象属性，属性值</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">//value:18, // 属性值</span></span><br><span class="line">    <span class="comment">//writeable:true, // 是否可以被修改 默认为false,不可以</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 是否可以被删除</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 是否可以枚举</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 访问 age 属性时会调用该方法，返回值就是age的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 修改age的值得时候，会调用该方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"></span><br><span class="line">******************************************</span><br><span class="line">    </span><br><span class="line">多个数据劫持</span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;Hi&#x27;</span>,</span><br><span class="line">    <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.keys 返回对象的所有的属性</span></span><br><span class="line"><span class="comment">// Object.values 返回对象的所有的属性值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReact</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, key, &#123;</span><br><span class="line">            <span class="title function_">get</span> () &#123;</span><br><span class="line">                <span class="keyword">return</span> data[key]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">set</span> (newValue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (newValue === data[key]) &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                data[key] = newValue</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 试图更新</span></span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">innerHTML</span> = data[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">defineReact</span>()</span><br></pre></td></tr></table></figure>

<p>缺陷：</p>
<ul>
<li>无法检测对象属性的新增和删除。若想实现，则通过Vue.set( (obj, propertName/index, value )或者Vue.delete( obj, propertyName/index )</li>
<li>无法检测到数组的变化。</li>
</ul>
<p>Proxy:是Vue3实现响应式的原理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;dmc&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// info 代理对象</span></span><br><span class="line"><span class="keyword">let</span> infoProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(info, &#123;</span><br><span class="line">    <span class="comment">// target 目标对象</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取对象属性&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置对象属性&#x27;</span>)</span><br><span class="line">    target[key] = newValue</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发has捕获器&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>优点：代理整个对象而非对象属性。可以监听数组的变化。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="一、-跨域问题"><a href="#一、-跨域问题" class="headerlink" title="一、 跨域问题"></a>一、 跨域问题</h2><p>概述：浏览器基于安全因素的考虑，是不允许进行跨域请求的，如果发生跨域请求，就会发生一下类似的错误。</p>
<p>跨域原因：</p>
<ul>
<li>协议：<code>http</code></li>
<li>域名：<code>baidu.com</code></li>
<li>端口号: <code>3000</code></li>
</ul>
<p>解决：解决方案有很多种，比如前端开发时进行<code>反向代理</code>，使用<code>JSONP</code>，后端设置<code>CORS</code>、配置 <code>nginx </code>反向代理等等</p>
<h3 id="1-CORS"><a href="#1-CORS" class="headerlink" title="1. CORS"></a>1. <code>CORS</code></h3><p>概述：跨域资源共享是一种机制，当一个资源访问到另一个资源时，资源就会发起一个跨域的http请求需要浏览器和服务器同时支持：</p>
<p><code>node.js</code>处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;*&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">      res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>); <span class="comment">// 表示允许哪些网站访问，上线后应该直接指定ip而不应该 *</span></span><br><span class="line">      res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;GET, POST, PUT, DELETE&#x27;</span>);</span><br><span class="line">      res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Content-Type,Content-Length, Authorization, Accept,X-Requested-With&#x27;</span>);</span><br><span class="line">      res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>);<span class="comment">//和客户端对应，必须设置以后，才能接收cookie.</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">next</span>();</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2. 反向代理"></a>2. 反向代理</h3><ul>
<li>Vue  config.js中配置</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>, <span class="comment">// 服务器地址</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 本地会虚拟一个服务端接受你的请求并代你发送该请求</span></span><br><span class="line">        <span class="attr">secure</span>: <span class="literal">false</span>, <span class="comment">// 代理某些 https 服务时用</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>React 在src目录下创建setupProxy.js文件</li>
<li>下载依赖</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i http-proxy-middleware -D</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;createProxyMiddleware&#125; = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">app</span>) &#123;</span><br><span class="line">    app.<span class="title function_">use</span>(<span class="title function_">createProxyMiddleware</span>(</span><br><span class="line">    <span class="string">&#x27;/mock&#x27;</span>,&#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>:&#123;</span><br><span class="line">            <span class="string">&#x27;^/mock&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Nginx"><a href="#3-Nginx" class="headerlink" title="3. Nginx"></a>3. Nginx</h3><h2 id="二、HTTP问题"><a href="#二、HTTP问题" class="headerlink" title="二、HTTP问题"></a>二、HTTP问题</h2><p>原理：HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>步骤：客户端连接到Web服务器->发送Http请求->服务器接受请求并返回HTTP响应->释放连接TCP连接->客户端浏览器解析HTML内容</p>
<h3 id="2-1-GET和POST请求"><a href="#2-1-GET和POST请求" class="headerlink" title="2.1 GET和POST请求"></a>2.1 GET和POST请求</h3><ul>
<li>应用场景：GET请求用于对服务器资源不会产生影响的场景。而POST请求一般用于对服务器资源会产生影响的场景。</li>
<li>是否缓存：浏览器一般会对GET请求进行缓存，但很少对POST请求进行缓存。</li>
<li>请求参数：GET请求使用URL进行传递参数，URL的？后面拼接参数，POST请求中的实体报文部分一般为服务器发送的数据。</li>
<li>安全性：因为GET请求的参数是拼接在URL后面的，所以安全性较差，因为请求的URL会被保留在历史记录中，而POST请求安全性较好。</li>
<li>请求长度：浏览器对URL有长度限制，因此会影响GET请求发送数据的长度，而POST请求并没有长度限制。</li>
<li>刷新：GET请求支持刷新和后退，而POST请求每次刷新都会重新发送</li>
<li>参数类型：POST请求的参数传递支持更多的数据类型</li>
</ul>
<h3 id="2-2-HTTP请求头和响应头"><a href="#2-2-HTTP请求头和响应头" class="headerlink" title="2.2 HTTP请求头和响应头"></a>2.2 HTTP请求头和响应头</h3><h4 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h4><ul>
<li>Accept:浏览器能够处理的内容类型</li>
<li>Accept-Charset:浏览器能够显示的字符集</li>
<li>Accept-Encoding：浏览器能够处理的压缩编码</li>
<li>Accept-Language：浏览器当前设置的语言</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cookie：当前页面设置的任何Cookie</li>
<li>Host：发出请求的页面所在的域</li>
<li>Referer：发出请求的页面的URL</li>
<li>User-Agent：浏览器的用户代理字符串</li>
</ul>
<h4 id="响应头："><a href="#响应头：" class="headerlink" title="响应头："></a>响应头：</h4><ul>
<li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li>
<li>server:服务器名称</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cache-Control：控制HTTP缓存</li>
<li>content-type:表示后面的文档属于什么MIME类型</li>
</ul>
<h3 id="2-3-HTTP状态码304"><a href="#2-3-HTTP状态码304" class="headerlink" title="2.3 HTTP状态码304"></a>2.3 HTTP状态码304</h3><p>概述：客户端有缓存情况下的服务端的一种响应客户端性能优化的一种方式</p>
<p>过多的304状态码可能会导致网站快照停止，收录减少，权重下降</p>
<h3 id="2-4-HTTP-1-0-和-HTTP-1-1"><a href="#2-4-HTTP-1-0-和-HTTP-1-1" class="headerlink" title="2.4 HTTP 1.0 和 HTTP 1.1"></a>2.4 HTTP 1.0 和 HTTP 1.1</h3><ul>
<li><strong>连接方面</strong>：1.0默认使用非持久连接，而1.1 默认使用持久连接。1.1通过使用持久连接来使多个http请求复用同一个TCP连接，一次来避免使用非持久连接时每件需要建立链接的时延。</li>
<li><strong>资源请求</strong>：1.0 中会存在一些浪费宽带的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。1.1 则在请求头引入 range 头域，他允许只请资源的某个部分，即返回码是206</li>
<li><strong>缓存方面</strong>： 1.0 主要使用了 header 里的  If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略 </li>
<li>1.1 新增加了 host 字段，用来指定服务器的域名。1.0 中并没有传递主机名。</li>
<li>1.1 新增加了很多的请求方法</li>
</ul>
<h3 id="2-5-HTTP-1-1-和-HTTP-2-0"><a href="#2-5-HTTP-1-1-和-HTTP-2-0" class="headerlink" title="2.5 HTTP 1.1 和 HTTP 2.0"></a>2.5 HTTP 1.1 和 HTTP 2.0</h3><ul>
<li><strong>二进制协议</strong>：1.1 中的豹纹的头信息必须是文本，数据体可以是文本，也可以是二进制。2.0 则是一个彻底的二进制协议，头信息和数据题都是二进制</li>
<li><strong>多路复用</strong>：2.0 实现了多路复用，任然复用TCP连接，但是在一个连接里，客户端和服务器都可以同时发送多喝请求或者回应，而且不用按照顺序一一发送。</li>
<li><strong>数据流</strong>：2.0使用了数据流的概念，因为2.0的数据包是不按顺序发送的，同一个链接里面连续的数据包，可能属于不同的请求。因此，必须对数据包做标记，指出他属于那个请求。2.0将每个请求或回应的所有数据包，成为一个数据流，每个数据流都有一个独一无二的编号。</li>
<li><strong>头信息压缩</strong>： HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。 </li>
<li><strong>服务器推送</strong>： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，。</li>
</ul>
<h3 id="2-6-HTTP和HTTPS"><a href="#2-6-HTTP和HTTPS" class="headerlink" title="2.6 HTTP和HTTPS"></a>2.6 HTTP和HTTPS</h3><ul>
<li>HTTPS 协议需要CA证书，费用较高；HTTP协议不需要</li>
<li>HTTP是超文本传输协议，信息是明文传输的；HTTPS则是具有安全性的SSL加密传输协议</li>
<li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443</li>
<li>HTTP协议连接很简单，是无状态的；HTTPS协议是由SSL和HTTP协议构建的可进行加密传输，身份认证的网络协议，比HTTP更加安全。</li>
</ul>
<h3 id="2-7-输入URL后发生了生么"><a href="#2-7-输入URL后发生了生么" class="headerlink" title="2.7 输入URL后发生了生么"></a>2.7 输入URL后发生了生么</h3><ul>
<li><strong>解析URL</strong>：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</li>
<li><strong>缓存判断</strong>：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</li>
<li><strong>DNS解析</strong>：下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</li>
<li><strong>获取MAC地址</strong>：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</li>
<li><strong>TCP三次握手</strong>：下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</li>
<li><strong>HTTPS握手</strong>：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</li>
<li><strong>返回数据</strong>：当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</li>
<li><strong>页面渲染</strong>：浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</li>
<li><strong>TCP四次挥手</strong>：最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li>
</ul>
<h3 id="2-8-请求报文"><a href="#2-8-请求报文" class="headerlink" title="2.8 请求报文"></a>2.8 请求报文</h3><ul>
<li><strong>请求行</strong>： 请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 </li>
<li><strong>请求头部</strong>： 请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分割<ul>
<li>User-Agent：产⽣请求的浏览器类型。 </li>
<li>Accept：客户端可识别的内容类型列表。 </li>
<li>Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。</li>
</ul>
</li>
<li><strong>空行</strong></li>
<li><strong>请求体</strong>：post put等请求携带的数据</li>
</ul>
<h3 id="2-9-响应报文"><a href="#2-9-响应报文" class="headerlink" title="2.9 响应报文"></a>2.9 响应报文</h3><ul>
<li><strong>响应行</strong>： 由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。 </li>
<li><strong>响应头</strong>：响应部首组成</li>
<li><strong>空行</strong></li>
<li><strong>响应体</strong>：服务器响应的数据</li>
</ul>
<h3 id="2-10-URL"><a href="#2-10-URL" class="headerlink" title="2.10 URL"></a>2.10 URL</h3><ul>
<li>协议：访问服务器获取资源时使用的协议</li>
<li>域名：资源服务器主机名或IP地址</li>
<li>端口：资源服务器监听的端口，不同的scheme有不同的默认端口（HTTP使用80作为默认端口）</li>
<li>路径：服务器上的资源路径。路径与服务器和scheme有关</li>
<li>文件名：打开的文件名称</li>
<li>参数：提供给服务器上的值</li>
<li>锚点：打开用户页面时滚动到该锚点位置</li>
</ul>
<h3 id="2-11-常见的状态码"><a href="#2-11-常见的状态码" class="headerlink" title="2.11 常见的状态码"></a>2.11 常见的状态码</h3><ul>
<li>2开头的表示成功<ul>
<li>一般见到的就是200</li>
</ul>
</li>
<li>3开头的表示重定向<ul>
<li>301永久重定向</li>
<li>302临时重定向</li>
<li>304表示可以在缓存中取数据（协商缓存）</li>
</ul>
</li>
<li>4开头表示客户端错误<ul>
<li>403跨域</li>
<li>404请求资源不存在</li>
</ul>
</li>
<li>5开头表示服务端错误<ul>
<li>50</li>
</ul>
</li>
</ul>
<h2 id="三、DNS"><a href="#三、DNS" class="headerlink" title="三、DNS"></a>三、DNS</h2><p>概述： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。 </p>
<p>作用： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。 </p>
<p>解析过程：</p>
<ul>
<li><strong>浏览器缓存</strong>：首先在浏览器缓存中查找对应的IP地址，如果查到直接返回，若找不到就继续下一步</li>
<li><strong>本地DNS服务器</strong>： 将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步 </li>
<li><strong>根域名服务器</strong>： 本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址 </li>
<li><strong>顶级域名服务器</strong>： 本地DNS服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址 </li>
<li><strong>权威域名服务器</strong>： 本地DNS服务器向权威域名服务器发送请求，域名服务器返回对应的结果 </li>
<li>本地DNS服务器将返回的结果保存在缓存中，便于下次使用</li>
<li>本地DNS服务器将返回结果返回给浏览器</li>
<li>用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</li>
</ul>
<p> 比如要查询 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。 </p>
<h2 id="四、网络模型"><a href="#四、网络模型" class="headerlink" title="四、网络模型"></a>四、网络模型</h2><ul>
<li><strong>应用层</strong>：为应用程序提供服务</li>
<li><strong>表示层</strong>：数据格式转化、数据加密</li>
<li><strong>会话层</strong>：建立、管理和维护会话</li>
<li><strong>传输层</strong>：建立、管理和维护端到端的连接</li>
<li><strong>网络层</strong>：IP选址及路由选择</li>
<li><strong>数据链路层</strong>：提供介质访问和链路管理</li>
<li><strong>物理层</strong>：物理层</li>
</ul>
<h2 id="五、TCP和UDP"><a href="#五、TCP和UDP" class="headerlink" title="五、TCP和UDP"></a>五、TCP和UDP</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">UDP</th>
<th align="center">TCP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否连接</td>
<td align="center">无连接</td>
<td align="center">面向连接</td>
</tr>
<tr>
<td align="center">是否可靠</td>
<td align="center">不可靠传输，不使用流量控制和拥塞控制</td>
<td align="center">可靠传输（数据顺序和正确性），使用流量控制和拥塞控制</td>
</tr>
<tr>
<td align="center">连接对象个数</td>
<td align="center">支持一对一，一对多，多对一和多对多交互通信</td>
<td align="center">只能是一对一通信</td>
</tr>
<tr>
<td align="center">传输方式</td>
<td align="center">面向报文</td>
<td align="center">面向字节流</td>
</tr>
<tr>
<td align="center">首部开销</td>
<td align="center">首部开销小，仅8字节</td>
<td align="center">首部最小20字节，最大60字节</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">适用于实时应用，例如视频会议、直播</td>
<td align="center">适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<p><strong>TCP重传机制</strong>： TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。 </p>
<p><strong>TCP三次握手</strong>：</p>
<ul>
<li>第一次握手： 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</li>
</ul>
<p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
<ul>
<li>第二次握手： 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</li>
</ul>
<p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p>
<ul>
<li>第三次握手： 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li>
</ul>
<p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
<p><strong>三次握手原因</strong>：客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
<p><strong>四次挥手</strong>：</p>
<ul>
<li>第一次挥手：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li>
<li>第二次挥手：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li>
<li>第三次挥手：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</li>
<li>第四次挥手：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li>
</ul>
<h2 id="六、缓存问题"><a href="#六、缓存问题" class="headerlink" title="六、缓存问题"></a>六、缓存问题</h2><h3 id="6-1-本地缓存、cookie、token"><a href="#6-1-本地缓存、cookie、token" class="headerlink" title="6.1 本地缓存、cookie、token"></a>6.1 本地缓存、cookie、token</h3><ul>
<li><p>cookie:网站为了标识用户身份而储存在客户端的数据。（不安全，考虑服务器性能适用cookie），每次http求情都会携带 	</p>
</li>
<li><p>localStorage和SessionStorage不会自动的把数据发给服务器，只会在本地保存</p>
</li>
<li><p>session：一般是用来存储用户会话所需的配置和信息，保存在服务端（安全，登录信息保存，其他信息如果需要保留，可以放在cookie中）</p>
</li>
</ul>
<p>存储大小：cookie大小一般不能超过4k，而 **localStorage、SessionStorage比cookie大得多，可以达到5M</p>
<p>有期事件：localStorage关闭浏览器后数据依然保留，除非手动清除，否则一直在</p>
<p>​					sessionStorage关闭浏览器或者标签后即失效</p>
<p>​					cookie一般由 server 设置值及过期时间</p>
<p>​					session的生命周期是间隔的</p>
<h3 id="6-2-浏览器缓存"><a href="#6-2-浏览器缓存" class="headerlink" title="6.2 浏览器缓存"></a>6.2 浏览器缓存</h3><p>浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力</p>
<p><strong>强缓存</strong>：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p>
<pre><code>    1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）
    1. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存
    1. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果
</code></pre>
<p>​	当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高</p>
<p><strong>协商缓存</strong>：协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用本地缓存的过程，主要有以下两种情况：</p>
<pre><code>1. 协商缓存生效，返回304
1. 协商缓存失效，返回200和请求结果结果
</code></pre>
<h2 id="七、浏览器"><a href="#七、浏览器" class="headerlink" title="七、浏览器"></a>七、浏览器</h2><h3 id="7-1-性能优化"><a href="#7-1-性能优化" class="headerlink" title="7.1 性能优化"></a>7.1 性能优化</h3><ul>
<li>减少http请求次数</li>
<li>对js和css打包，资源合并</li>
<li>适用雪碧图，把请求的icon合并成一张图片</li>
<li>给资源做缓存</li>
<li>图片按需加载（懒加载）</li>
<li>CDN减少打包体积</li>
<li>异步加载js文件</li>
<li>开启gzip打包</li>
<li>路由懒加载，图片懒加载</li>
<li>预渲染和服务端渲染</li>
<li>组件的按需加载</li>
</ul>
<h3 id="7-2-渲染机制"><a href="#7-2-渲染机制" class="headerlink" title="7.2 渲染机制"></a>7.2 渲染机制</h3><ul>
<li><code>HTML</code>被HTML解析器解析成<code>DOM</code> 树</li>
<li><code>css</code>则被css解析器解析成<code>CSSOM </code>树</li>
<li>结合<code>DOM</code>树和<code>CSSOM</code>树，生成一棵渲染树(<code>Render Tree</code>)</li>
<li>.根据生成的渲染树，进行回流（Layout）,得到节点的几何信息（位置，大小）</li>
<li>重绘（Painting）：根据渲染树以及回流得到的几何信息，得到节点的绝对<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%83%8F%E7%B4%A0&spm=1001.2101.3001.7020">像素</a>（像素，背景色，外观等）</li>
<li>Display将像素发送给GPU，展示在页面上</li>
</ul>
<p>回流(重排)： 当<code>DOM</code>的变化影响了元素位置和尺寸大小，浏览器需要重新计算元素的几何属性</p>
<ul>
<li><p>页面第一次加载时进行一次回流</p>
</li>
<li><p>当元素的 width、height、margin、padding、left、top 发生改变的时候会发生回流、</p>
</li>
<li><p>使 DOM节点增减或移动</p>
</li>
<li><p>读写 offset、client、scroll 时，浏览器为了获取这些值，会进行回流操作</p>
</li>
<li><p>使用 <code>window.getComputedStyle</code>的时候</p>
</li>
</ul>
<p>重绘：</p>
<ul>
<li>当改变元素时，只是改变了它的外观，比如背景颜色等，而没有影响到它的布局，这个时候会发生重绘</li>
<li>回流(重排)必将引起重绘；重绘不一定会引起回流(重排)</li>
</ul>
<p>如何避免或减少：</p>
<ul>
<li>避免逐次改变样式，样式统一批量修改</li>
<li>DOM离线处理，减少回流重绘次数<ul>
<li>使用document fragment在DOM Tree之外建立一个子树</li>
<li>position属性控制其脱离文档流</li>
</ul>
</li>
<li>CSS3硬件加速（GPU加速）</li>
</ul>
<h3 id="7-3-XSS和CSRF攻击"><a href="#7-3-XSS和CSRF攻击" class="headerlink" title="7.3 XSS和CSRF攻击"></a>7.3 XSS和CSRF攻击</h3><p>xss：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。<code>跨域脚本攻击</code></p>
<p>防御：</p>
<ul>
<li>编码：对用户输入的数据进行HTML Entity 编码。把字符转换成 转义字符。Encode的作用是将$var等一些字符进行转化，使得浏览器在最终输出结果上是一样的。</li>
<li>过滤：移除用户输入的和事件相关的属性。</li>
</ul>
<p>csrf：在未退出A网站的前提下访问B，B使用A的cookie去访问服务器。<code>跨站请求伪造</code></p>
<p>防御：</p>
<ul>
<li>使用验证码或者 token 验证，每次提交表单时需要带上 token（伪造者访问不到），如果 token 不合法，服务器拒绝请求</li>
<li>通过 host+origin 来判断是否为非法用户</li>
<li>给 Cookie 设置 SameSite属性，来限制第三方 Cookie，里面有三个值 strict、lax、none</li>
</ul>
<h3 id="7-4-进程和线程"><a href="#7-4-进程和线程" class="headerlink" title="7.4 进程和线程"></a>7.4 进程和线程</h3><p>进程是程序的一次执行，他占有一片独有的内存空间；可以通过windows任务管理器查看</p>
<p>线程是进程内的一个独立执行单元；是程序执行的一个完整的流程；是CPU的最小的调度单元</p>
<p>【联系】： 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；<br>资源分配给进程，同一进程的所有线程共享该进程的所有资源；<br>处理机分给线程，即真正在处理机上运行的是线程；</p>
<h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><h3 id="VUE的优点"><a href="#VUE的优点" class="headerlink" title="VUE的优点"></a>VUE的优点</h3><ol>
<li>简单易学</li>
<li>轻量级框架</li>
<li>渐进式引入</li>
<li>双向数据绑定</li>
<li>组件化开发</li>
<li>结构，数据，视图0分离</li>
</ol>
<h3 id="SPA页面："><a href="#SPA页面：" class="headerlink" title="SPA页面："></a>SPA页面：</h3><p>仅在web页面初始化时加载相应的HTML，CSS，JavaScript.一但页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转，取而代之的是利用路由机制实现HTML内容的变化，UI与用户的交互，避免也免得重新加载。</p>
<ul>
<li><p>优点：</p>
<ul>
<li><p>用户体验好，避免了不必要的跳转和重新渲染。</p>
</li>
<li><p>相对对服务器压力小</p>
</li>
<li><p>前后端职责分离，架构清晰。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>初次加载时耗时多</li>
<li>前进后退路由管理</li>
<li>SEO难度较大</li>
</ul>
</li>
</ul>
<h3 id="1-vue双向绑定的原理"><a href="#1-vue双向绑定的原理" class="headerlink" title="1. vue双向绑定的原理"></a>1. vue双向绑定的原理</h3><p>vue是采用数据劫持配合发布者-订阅者的模式的方式，通过Object.defineProperty()来劫持各个属性的getter和setter，在数据发生变动时发布消息给订阅者，触发相应的监听回调。具体为：需要observe的数据对象进行遍历，并对其和子属性添加getter和setter，Dep负责管理数据的依赖列表，compile解析模板指令，生成指令对象，每个指令对象绑定一个watcher对象，会触发getter,收集到dep仓库中，然后数据更新时就会触发setter，这时候相应的watcher对其再次求值，如果值确实发生变化了，就会通知相应的指令，调用指令的update方法，由对DOM做更新，这就实现了数据驱动DOM的变化。同时vue还会对DOM做事件监听，如果DOM发生变化，vue监听到，就会修改相应的data。</p>
<h3 id="Vue单向数据流"><a href="#Vue单向数据流" class="headerlink" title="Vue单向数据流"></a>Vue单向数据流</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>父级 prop 的更新会向下流动到子组件中，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值</p>
<h3 id="2-Vue监听数组"><a href="#2-Vue监听数组" class="headerlink" title="2. Vue监听数组"></a>2. Vue监听数组</h3><p>首先第一点是要看数组里面是不是还存在对象，如果存在对象的话在进行深层遍历是否还依然存在对象，再把对象进行 defineProperty监听。然后数组的改变实质上只是几个方法，什么 pop，unshift，push…Vue 重写了这几个方法，只要在调用这些方法的时候做出回调更新就可以了</p>
<h3 id="3-nextTick"><a href="#3-nextTick" class="headerlink" title="3. nextTick"></a>3. nextTick</h3><p>解释：就是当页面上的元素被重新渲染之后，才会执行回调函数中的代码(涉及事件循环机制)</p>
<p>正是因为Vue是异步更新Dom，所以当我们修改数据之后，Dom节点的内容不会立即修改，我们这样获取Dom节点的新内容的时候，获取的还是旧的内容</p>
<p>应用：1. 想要在Vue生命周期函数中的<code>created()</code>操作DOM可以使用<code>Vue.nextTick()</code>回调函数</p>
<ol start="2">
<li>在数据改变后要执行的操作，而这个操作需要等数据改变后而改变DOM结构的时候才进行操作，需要用到<code>nextTick</code></li>
</ol>
<p><strong>Vue在一个tick中多次更新数据页面只会更新一次</strong></p>
<p>数据 name 被 页面引用，name 会收集到 页面的 watcher；<br>name 被修改时，会通知所有收集到的 watcher 进行更新（watcher.update）；<br>如果name 一时间被修改三次时，按道理应该会通知三次 watcher 更新，那么页面会更新三次，但是最后只会更新一次。<br>这是因为：<br>当数据变化后，把 watcher.update 函数存放进 nextTick 的 回调数组中，并且会做过滤。<br>通过 watcher.id 来判断 回调数组 中是否已经存在这个 watcher 的更新函数不存在，才 push。<br>之后 nextTick时 遍历回调数组，便会执行了更新。</p>
<p>所以当三次修改数据的时候，会 push 回调数组 三个 watcher.update，但是只有第一次是 push 成功的，其他的会被过滤掉，因为已经存在了。<br>所以，不管你修改多少次数据，nextTick 的回调数组中只存在唯一一个 watcher.update，从而页面只会更新一次。</p>
<h3 id="4-Vue生命周期"><a href="#4-Vue生命周期" class="headerlink" title="4. Vue生命周期"></a>4. Vue生命周期</h3><p>实例化创建，初始化数据，编译模板，挂载dom，渲染，数据的更新，渲染以及销毁，vue提供了一些生命周期函数，我们可以编写代码使得vue被实例化的过程中能够完成我们的需求。</p>
<ul>
<li>beforeCreate<ul>
<li>创建之前，此时还没有data和Method</li>
<li>加一些loading效果。</li>
</ul>
</li>
<li>Created<ul>
<li>创建完成，此时data和Method可以使用了,不能访问dom节点</li>
<li>在Created之后beforeMount之前如果没有el选项的话那么此时生命周期结束，停止编译，如果有则继续</li>
</ul>
</li>
<li>beforeMount<ul>
<li>在渲染之前，压面呈现的是未经Vue编译的DOM结构，所有对DOM的操作都不奏效。</li>
</ul>
</li>
<li>mounted<ul>
<li>页面已经渲染完成，，这个时候可以操作DOM了（但是是获取不了元素的高度等属性的，如果想要获取，需要使用<code>nextTick()</code>）</li>
<li>开启定时器，发送网络请求，绑定自定义事件等初始化操作</li>
</ul>
</li>
<li>beforeUpdate<ul>
<li>数据是新的，页面是旧的。</li>
</ul>
</li>
<li>updated<ul>
<li>页面与数据保持同步</li>
</ul>
</li>
<li>beforeDestory<ul>
<li>在实例销毁之前，此时data,methods,指令仍然可以使用</li>
<li>关闭定时器，取消订阅消息，解绑自定义事件</li>
</ul>
</li>
<li>destoryed<ul>
<li>实例销毁后</li>
</ul>
</li>
</ul>
<p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>activated</code> 钩子函数。</p>
<p>nexttick:就是当页面上的元素被重新渲染之后，才会执行回调函数中的代码</p>
<h3 id="5-computed-、watch、method的区别"><a href="#5-computed-、watch、method的区别" class="headerlink" title="5. computed 、watch、method的区别"></a>5. computed 、watch、method的区别</h3><ul>
<li><p>computed</p>
<ul>
<li>计算属性，依赖其他属性，当其他属性改变的时候下一次获取computed值时也会改变，<code>computed</code>的值会有缓存</li>
<li>监控自己定义的变量，改变量不在data中声明，而是在computed里面定义</li>
<li>计算属性不能向服务器发送请求或者执行异步任务</li>
</ul>
</li>
<li><p>watch</p>
<ul>
<li>监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用</li>
<li>定义的变量在data中声明</li>
<li>如果想深度监听的话，后面加一个<code>deep:true</code></li>
<li>如果想监听完立马运行的话，后面加一个<code>immediate:true</code></li>
</ul>
</li>
<li><p>而对于method ，只要发生重新渲染，method 调用总会执行该函数。</p>
</li>
</ul>
<p><code>computed</code>：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能 <code>watch</code>：当一条数据影响多条数据的时候使用，例：搜索数据</p>
<h3 id="6-Vue性能优化"><a href="#6-Vue性能优化" class="headerlink" title="6. Vue性能优化"></a>6. Vue性能优化</h3><ol start="4">
<li><p>图片懒加载</p>
<ul>
<li>一张图片就是一个<code>&lt;img&gt;</code>标签，浏览器是否发起请求图片是根据<code>&lt;img&gt;</code>的src属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给<code>&lt;img&gt;</code>的src赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给src赋值。</li>
</ul>
</li>
<li><p>路由懒加载</p>
<ul>
<li>将路由相关的组件，不再直接导入了，而是改写成异步组件的写法，只有当函数被调用的时候，才去加载对应的组件内容。路由懒加载就是只加载你当前点击的那个模块</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/login/index.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/home/home.vue&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line"> <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Login</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;</span><br><span class="line">  ]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line"> <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>, <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/login/index.vue&#x27;</span>) &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/home/home.vue&#x27;</span>) &#125;</span><br><span class="line">  ]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
</li>
<li><p>CDN：内容分发网络。采用更多的服务器分布于用户访问相对集中的地方。当用户访问时，就会访问最近的服务器上，响应用户的请求。</p>
</li>
<li><p>使用字体图标代替图片图标</p>
</li>
<li><p>gzip压缩文件：通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。 </p>
</li>
<li><p>长列表虚拟滚动：只渲染可视区域的列表项，非可见区域的不渲染。在滚动时动态更新可视区域。原理：计算出列表的总高度，并在触发滚动事件时根据滚动长度实时更新预留缓冲区域高度，以此来从列表数据中截取。</p>
</li>
</ol>
<h3 id="7-Vue-router"><a href="#7-Vue-router" class="headerlink" title="7. Vue-router"></a>7. Vue-router</h3><ul>
<li>vue 的一个插件库，专门用来实现 SPA 应用。原理：检测url的变化，截获url地址，然后解析来匹配路由规则</li>
</ul>
<ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<ul>
<li><p>实现切换：<strong>router-link</strong>,指定展示位置：<strong>router-view</strong>.若是多级路由，可用children进行配置。</p>
</li>
<li><p><strong>两种方式进行传参</strong>：query传参和params进行传参。$router.query.id或者$router.params.id接收参数</p>
</li>
<li><p><strong>router-link的replace属性</strong>：控制路由跳转时操作浏览器历史记录的模式，浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></p>
</li>
<li><p><strong>编程式路由导航</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">		<span class="attr">params</span>:&#123;</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">		<span class="attr">params</span>:&#123;</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>() <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>keep-alive</strong>：让不展示的路由组件保持挂载，不被销毁</li>
</ul>
<p>缓存多个用数组，缓存一个用字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=<span class="string">&quot;News&quot;</span>&gt; </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p><strong>activated和deactivated</strong></p>
<p>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```deactivated```路由组件失活时触发。</span><br><span class="line"></span><br><span class="line">应用：可以将定时器写在被激活时里，销毁定时器写在失活里，组件跳转时会被触发</span><br><span class="line"></span><br><span class="line">- **路由守卫**：全局守卫(前置和后置)、独享守卫、组件内守卫(进入守卫和离开守卫)</span><br><span class="line"></span><br><span class="line">​		作用：对路由进行权限控制</span><br><span class="line"></span><br><span class="line">​		全局守卫(前置和后置)</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">//全局前置守卫：初始化时执行、每次路由切换前执行</span><br><span class="line">router.beforeEach((to,from,next)=&gt;&#123;</span><br><span class="line">	console.log(&#x27;beforeEach&#x27;,to,from)</span><br><span class="line">	if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制</span><br><span class="line">		if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; //权限控制的具体规则</span><br><span class="line">			next() //放行</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			alert(&#x27;暂无权限查看&#x27;)</span><br><span class="line">			// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		next() //放行</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//全局后置守卫：初始化时执行、每次路由切换后执行</span><br><span class="line">router.afterEach((to,from)=&gt;&#123;</span><br><span class="line">	console.log(&#x27;afterEach&#x27;,to,from)</span><br><span class="line">	if(to.meta.title)&#123; </span><br><span class="line">		document.title = to.meta.title //修改网页的title</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		document.title = &#x27;vue_test&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<pre><code>       独享守卫:
</code></pre>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line">			<span class="title function_">next</span>()</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		组件内守卫：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//进入守卫：通过路由规则，进入该组件时被调用</span><br><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line">//离开守卫：通过路由规则，离开该组件时被调用</span><br><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>路由模式：</strong></p>
<ul>
<li><h6 id="1-hasn模式"><a href="#1-hasn模式" class="headerlink" title="1. hasn模式"></a>1. hasn模式</h6><ul>
<li><code>hash</code> 模式是一种把前端路由的路径用井号 <code>#</code> 拼接在真实 <code>url</code> 后面的模式。当井号 <code>#</code> 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 <code>onhashchange</code> 事件。不会被包括在 <code>http</code> 请求中。</li>
<li>hash变化会触发网页跳转，即浏览器的前进和后退。</li>
<li><code>hash</code> 通过 <code>window.onhashchange</code> 的方式，来监听 <code>hash</code> 的改变，借此实现无刷新跳转的功能</li>
<li><code>hash</code> 可以改变 <code>url</code> ，但是不会触发页面重新加载，不会出现在``http`中</li>
<li>首先，<code>hash</code>本来是拿来做页面定位的，如果拿来做路由的话，原来的锚点功能就不能用了。其次，``hash<code>的传参是基于</code>url`的，如果要传递复杂的数据，会有体积的限制</li>
</ul>
<h6 id="2-history模式"><a href="#2-history模式" class="headerlink" title="2. history模式"></a>2. history模式</h6><ul>
<li>利用H5的 history中新增的两个API <code>pushState()</code> 和 <code>replaceState()</code> 和一个事件``onpopstate`监听URL变化</li>
<li><code>history</code>每次刷新会重新像后端请求整个网址，也就是重新请求服务器。如果后端没有及时响应，就会报错404！ </li>
<li><code>history</code>模式不仅可以在``url`里放参数，还可以将数据存放在一个特定的对象中。</li>
<li>修改历史状态：  包括了 HTML5 History Interface 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了 url，但浏览器不会立即向后端发送请求。如果要做到改变 url 但又不刷新页面的效果，就需要前端用上这两个 API。 </li>
<li>切换历史状态： 包括 <code>forward()</code>、<code>back()</code>、<code>go()</code> 三个方法，对应浏览器的前进，后退，跳转操作。</li>
</ul>
<h6 id="3-两种模式对比"><a href="#3-两种模式对比" class="headerlink" title="3. 两种模式对比"></a>3. 两种模式对比</h6><ul>
<li>history 模式的 pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li>
<li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li>
<li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li>
<li>pushState() 可额外设置 title 属性供后续使用。</li>
<li>hash 模式下，仅 hash 符号之前的 url 会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回 404 错误；history 模式下，前端的 url 必须和实际向后端发起请求的 url一致，如果没有对用的路由处理，将返回 404 错误。</li>
</ul>
</li>
<li><p>怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</p>
<ul>
<li>在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id获取动态参数</li>
</ul>
</li>
</ul>
<h3 id="8-diff算法"><a href="#8-diff算法" class="headerlink" title="8. diff算法"></a>8. diff算法</h3><ul>
<li>diff算法是指对新旧虚拟节点进行对比，并返回一个patch对象，用来存储两个节点不同的地方，最后利用patch记录的消息局部更新DOM</li>
<li>diff 算法<ul>
<li>diff算法是虚拟节点的比较</li>
<li>tag不同认为是不同节点</li>
<li>进行key值的比较</li>
<li>先进行同级比较，</li>
<li>然后再比较是不是一方有儿子，一方没儿子</li>
</ul>
</li>
<li>React和Vue：<ul>
<li>在React中，当数据发生改变的时候，组件数就会自顶向下的全diff，重新render页面，重新生成新的虚拟dom tree，新旧dom tree进行比较，进行打补丁的方式，局部更新dom。所以react为了避免组件更新而引起不必要的子组件更新，可以再shouldComponentUpdate做逻辑判断，减少不必要的render，以及重新生成虚拟dom</li>
<li>react 首先对新集合进行遍历，通过唯一key值来判断新旧集合中是否存在相同的节点，如果没有的话就创建，如果有的话就会将节点在新集合中的位置和老集合中的位置进行比较，如果不同，则进行移动操作，否则就不操作。如果在遍历的过程中，发现在新集合中没有，就会进行删除操作。</li>
<li>在Vue中，通过Object.defineProperty吧data属性全部转为getter/setter。同时watcher实例对象会在组件渲染时，将属性记录为dep，当dep中的setter被调用时，通知watch重新计算，使得关联组件更新</li>
<li>Vue新旧集合各有头尾的变量，他们的2各变量相互比较，一共有四种比较方式，如果四种都没匹配，则会匹配key值，借助key值找到可复用的节点，在进行相关操作。</li>
</ul>
</li>
</ul>
<h3 id="9-虚拟DOM"><a href="#9-虚拟DOM" class="headerlink" title="9. 虚拟DOM"></a>9. 虚拟DOM</h3><p>概述：本质上是JS和DOM之间的一个映射缓存，它表现为一个能够描述DOM结构及其属性信息的JS对象。主要存储在内存中。</p>
<ul>
<li>虚拟DOM是一个JS对象，存储在内存之中</li>
<li>能够描述真实DOM</li>
<li>当数据变化的时候，生成新的DOM，对比新旧虚拟DOM的差异，将差异更新到 真实DOM上。</li>
</ul>
<p>虚拟DOM优缺点：</p>
<ul>
<li>缺点<ul>
<li>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢</li>
</ul>
</li>
<li>优点<ul>
<li>减少了dom操作，减少了回流与重绘</li>
<li>保证性能的下限，但是它具备局部更新的能力，所以大部分时候还是比正常的DOM性能高很多的</li>
</ul>
</li>
</ul>
<h3 id="10-Vue的key（index）"><a href="#10-Vue的key（index）" class="headerlink" title="10. Vue的key（index）"></a>10. Vue的key（index）</h3><ul>
<li>key主要用在虚拟Dom算法中，每个虚拟节点有一个唯一标识Key，通过对比新旧节点的key来判断节点是否改变，用key就可以大大提高渲染效率</li>
<li>使用Index作为key可能会引发的问题<ul>
<li>若对数据进行: 逆序添加, 逆序删除等破坏顺序操作,会产尘没有必要的真实DOM更新, 界面效果没问题, 但效率低</li>
<li>如果结构中还包含输入类的DOM, 例如 input 标签,会产生错误DOM更新, 界面有问题</li>
</ul>
</li>
</ul>
<h3 id="11-vue组件之间的通信（vuex）"><a href="#11-vue组件之间的通信（vuex）" class="headerlink" title="11. vue组件之间的通信（vuex）"></a>11. vue组件之间的通信（vuex）</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6999687348120190983#heading-15">https://juejin.cn/post/6999687348120190983#heading-15</a></p>
<ul>
<li><p>父传子</p>
<ul>
<li>父组件设置<code>v-bind:</code>/<code>:</code>,子组件设置<strong>props</strong>接受 + <strong>不能直接修改</strong>父组件的数据</li>
<li>使用**.sync<strong>通信，:num.sync="num" ,子组件用props接收传递的值(绑定的属性名自己决定) 在子组件中通过$emit方法触发<code>&#39;update:属性名&#39;</code>事件 实现父组件子组件值同时变化</strong>this.$emit('update:属性名',要修改的值)**@update:num</li>
<li>使用<strong>v-model</strong>通信，v-model="num",  ,子组件用props接收传递的值value, 在子组件中通过$emit方法触发input事件 实现父组件子组件值同时变化  **<code>this.$emit(&#39;input&#39;,this.value+1)</code></li>
</ul>
</li>
<li><p>子传父</p>
<ul>
<li>自定义事件：在父组件v-on绑定自定义事件，在子组件通过$emit触发事件，第一个参数为事件名称，第二个参数为要传递的参数。</li>
<li>通过父组件给子组件传递函数类型的props实现：子给父传递</li>
</ul>
</li>
<li><p><strong>ref</strong> 如果在普通的DOM元素上，引用指向的就是该DOM元素;</p>
<p>如果在子组件上，引用的指向就是子组件实例，然后父组件就可以通过 $ref 主动获取子组件的属性或者调用子组件的方法</p>
</li>
<li><p>任意组件</p>
<ul>
<li><p>传说中的**$bus**</p>
<ul>
<li><pre><code class="js">new Vue(&#123;
    ......
    beforeCreate() &#123;
        Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
    &#125;,
    ......
&#125;) 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">使用：*在需要向外部发送自定义事件的组件内*通过this.$bus.$emit发送数据</span><br><span class="line">  </span><br><span class="line">*在需要接收外部事件的组件内*通过$on监听事件的触发并接受数据。</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">methods()&#123;</span><br><span class="line">  demo(data)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">mounted() &#123;</span><br><span class="line">  this.$bus.$on(&#x27;xxxx&#x27;,this.demo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>Vuex</p>
<ul>
<li>集中式存储管理所有组件的状态</li>
</ul>
</li>
<li><p>[<a target="_blank" rel="noopener" href="https://juejin.cn/post/6928468842377117709#heading-8]">https://juejin.cn/post/6928468842377117709#heading-8]</a>: </p>
<ul>
<li>state<ul>
<li>存储数据的</li>
<li>获取数据最好推荐使用getters</li>
<li>硬要使用的话可以用MapState， 先引用，放在compute中<code>...mapState([&#39;方法名&#39;,&#39;方法名&#39;])</code></li>
</ul>
</li>
<li>getters<ul>
<li>. 值为一个对象，包含多个用于返回数据的函数。函数第一个参数为state</li>
<li>对state中的数据进行操作和加工，</li>
</ul>
</li>
<li>mutations<ul>
<li>同步操作数据的</li>
<li>值为一个对象，包含多个响应用户动作的回调函数</li>
<li>组件中使用this.$store.commit(“方法名”,数据)触发</li>
<li>也可使用mapMutations ，使用方法和以上一样</li>
</ul>
</li>
<li>actions<ul>
<li>异步操作数据的</li>
<li>值为一个对象，包含多个响应用户动作的回调函数</li>
<li>通过 commit( )来触发 mutation 中函数的调用</li>
<li>组件中使用this.$store.dispatch(“方法名”,数据)触发 </li>
<li>也可使用mapActions ，使用方法和以上一样</li>
</ul>
</li>
<li>modules<ul>
<li>一个 module 是一个 store 的配置对象</li>
</ul>
</li>
</ul>
<p>引用vuex:</p>
<ul>
<li><p>先安装依赖<code>nnpm install vuex --save</code></p>
</li>
<li><p>在项目目录src中建立store文件夹</p>
</li>
<li><p>在store文件夹下新建index.js文件,写入</p>
</li>
<li><pre><code class="js">import Vue from &#39;vue&#39;;
import Vuex from &#39;vuex&#39;;
Vue.use(Vuex);
//不是在生产环境debug为true
const debug = process.env.NODE_ENV !== &#39;production&#39;;
//创建Vuex实例对象
const store = new Vuex.Store(&#123;
    strict:debug,//在不是生产环境下都开启严格模式
    state:&#123;
    &#125;,
    getters:&#123;
    &#125;,
    mutations:&#123;
    &#125;,
    actions:&#123;
    &#125;
&#125;)
export default store;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 然后再main.js文件中引入Vuex,这么写</span><br><span class="line">  </span><br><span class="line">- ```js</span><br><span class="line">  import Vue from &#x27;vue&#x27;;</span><br><span class="line">  import App from &#x27;./App.vue&#x27;;</span><br><span class="line">  import store from &#x27;./store&#x27;;</span><br><span class="line">  const vm = new Vue(&#123;</span><br><span class="line">      store:store,</span><br><span class="line">      render: h =&gt; h(App)</span><br><span class="line">  &#125;).$mount(&#x27;#app&#x27;)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>vuex的 store 中的数据是保存在运行内存中的，当页面刷新时，页面会重新加载 vue 实例，vuex 里面的数据就会被重新赋值，这样就会出现页面刷新vuex中的数据丢失的问题。 如何解决浏览器刷新数据丢失问题呢？</strong></p>
<ol>
<li>方法一：全局监听，页面刷新的时候将 store 里 state 的值存到 sessionStorage 中，然后从sessionStorage 中获取，再赋值给 store ，并移除 sessionStorage 中的数据。</li>
<li>安装 vuex-persistedstate 插件，在vuex实例对象后添加插件</li>
</ol>
<p>vuex-persistedstate 默认使用 localStorage 来存储数据，若要实现无痕浏览该如何实现呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">persistedState</span>(&#123; <span class="attr">storage</span>: <span class="variable language_">window</span>.<span class="property">sessionStorage</span> &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h3 id="12-Vue-router有哪几种钩子函数"><a href="#12-Vue-router有哪几种钩子函数" class="headerlink" title="12. Vue-router有哪几种钩子函数"></a>12. <strong>Vue-router有哪几种钩子函数</strong></h3><p>全局守卫(前置和后置)、独享守卫、组件内守卫(进入守卫和离开守卫)</p>
<ul>
<li><p>beforeEach(全局前置守卫)</p>
<ul>
<li>初始化时执行、每次路由切换前执行</li>
<li>判断当前路由是否需要进行权限控制</li>
</ul>
</li>
<li><p>afterEach(全局后置守卫)</p>
<ul>
<li>初始化时执行、每次路由切换后执行</li>
</ul>
</li>
<li><p>beforeRouterLeave</p>
</li>
</ul>
<h3 id="13-为什么组件中-data-是个函数"><a href="#13-为什么组件中-data-是个函数" class="headerlink" title="13. 为什么组件中 data 是个函数"></a>13. <strong>为什么组件中 data 是个函数</strong></h3><p>在 Vue 底层中，在每次创建组件的时候，都会 new 一个VueComponent实例对象，他们的 data会挂载到VueComponent 的原型上共享，如果是一个对象的话，所有人都可以修改，但是如果是一个函数返回值的话就可以创建一个私有作用域来避免互相污染。</p>
<h3 id="14-v-model"><a href="#14-v-model" class="headerlink" title="14. v-model"></a>14. v-model</h3><p>语法糖，v-bind绑定响应式数据，v-on触发事件并触发数据。用于表单数据的双向绑定。监听用户的输入事件已更新数据，初始值为VUE实例的数据作为数据来源。父子组件中使用v-model通信 ,子组件用props接收传递的值value(一定要叫value) 在子组件中通过$emit方法触发input事件 实现父组件子组件值同时变化</p>
<p>组件绑定<code>v-model</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;<span class="title class_">Component</span> v-model=<span class="string">&#x27;data&#x27;</span>&gt;&lt;/<span class="title class_">Component</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;checkbox&quot;</span><br><span class="line">      v-bind:checked=&quot;checked&quot;</span><br><span class="line">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span><br><span class="line">    &gt;</span><br><span class="line"> &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">	name:&#x27;Component&#x27;,</span><br><span class="line">        model:&#123;</span><br><span class="line">           prop: &#x27;checked&#x27;,</span><br><span class="line">    	event: &#x27;change&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        props:&#123;</span><br><span class="line">            checked:Boolean</span><br><span class="line">        &#125;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="15-v-html和v-text"><a href="#15-v-html和v-text" class="headerlink" title="15. v-html和v-text"></a>15. v-html和v-text</h3><p>浏览器解析不出html代码，会将它当做普通文本。v-html就可以解析为标签，而v-text只会解析为文本。</p>
<p>v-html可能会造成xss攻击，v-html 会替换掉子标签</p>
<h3 id="17-vue2-0和3-0"><a href="#17-vue2-0和3-0" class="headerlink" title="17. vue2.0和3.0"></a>17. vue2.0和3.0</h3><p>vue2 的双向数据绑定是利用ES5 的一个 API ，Object.definePropert()对数据进行劫持 结合 发布订阅模式的方式来实现的。<br>vue3 中使用了 es6 的 ProxyAPI 对数据代理，通过 reactive() 函数给每一个对象都包一层 Proxy，通过 Proxy 监听属性的变化，从而实现对数据的监控。</p>
<ul>
<li>可以监听动态新增的属性；</li>
<li>可以监听删除的属性 ；</li>
<li>可以监听数组的变化；</li>
</ul>
<p>采用ts编写</p>
<p><strong>使用proxy的优势</strong></p>
<ol>
<li>可直接监听数组类型的数据变化</li>
<li>监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升</li>
<li>可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行</li>
<li>直接实现对象属性的新增/删除</li>
</ol>
<h3 id="18-vue的-set"><a href="#18-vue的-set" class="headerlink" title="18. vue的$set"></a>18. <strong>vue的$set</strong></h3><p>vue 中 data的数据，如果是对象的话，会把它的属性转为Object.defineProperty的getter和setter，使之变为响应式的。</p>
<p><strong>如果在实例创建之后添加新的属性到实例上，它不会触发视图更新</strong>,比如data中有一个对象具有name和sex属性，想追加一个age属性，增加成功但是不贵在视图上进行显示。因为在创建实例的时候 缺少了vue 监听的 set、get属性(直接在mounted中，用<code>$set</code>方法添加进去)<code>this.$set(this.student,&quot;age&quot;,24)</code></p>
<h3 id="19-v-if和v-for"><a href="#19-v-if和v-for" class="headerlink" title="19. v-if和v-for"></a>19. v-if和v-for</h3><p>在v-if和v-for用在同一个元素上时，因为v-for要比v-if的优先级高，所以会先执行循环，再进行判断，这样无论条件判断的结果如何，循环都会执行。所以要避免她们用在一起，如果需要的话，可以在外层加一个template，v-if用在template上，这样就可以实现先判断再根据判断结果决定是否执行循环了。</p>
<h3 id="20-v-if-和-v-show"><a href="#20-v-if-和-v-show" class="headerlink" title="20. v-if 和 v-show"></a>20. <strong>v-if 和 v-show</strong></h3><p>v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</p>
<p>v-show适合频繁切换,v-if适合运行条件不大可能改变</p>
<h3 id="21-插槽"><a href="#21-插槽" class="headerlink" title="21. 插槽"></a>21. 插槽</h3><p>Slot 通俗的理解就是“占坑”，在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑</p>
<p>让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式</p>
<p>作用域插槽：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定，通过 “slot-scope” 来接收子组件传过来的插槽数据，再根据插槽数据来填充插槽的内容</p>
<h3 id="22-自定义事件"><a href="#22-自定义事件" class="headerlink" title="22. 自定义事件"></a>22. 自定义事件</h3><p>一种组件间通信的方式</p>
<ol>
<li>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</li>
<li>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code>		</li>
<li>解绑自定义事件```this.$off('atguigu')`</li>
</ol>
<h3 id="23-在使用计算属性时，函数名与data中的数据名可以同名吗"><a href="#23-在使用计算属性时，函数名与data中的数据名可以同名吗" class="headerlink" title="23. 在使用计算属性时，函数名与data中的数据名可以同名吗"></a>23. 在使用计算属性时，函数名与data中的数据名可以同名吗</h3><p>不可以。</p>
<p>在初始化的时，props、methods、data、computed、watch会依次绑定到vm上，因此，当方法名与数据名重复时，会覆盖掉上一个。</p>
<h3 id="24-vue打包后静态资源路径"><a href="#24-vue打包后静态资源路径" class="headerlink" title="24. vue打包后静态资源路径"></a>24. vue打包后静态资源路径</h3><p> 1、确定线上环境是否在根路径上，配置资源根目录，vue-cli2 和 vue-cli3 字段不一致（assetsPublicPath 和 publicPath ），如果项目是根路径上，用'/'，'./'都行，如果是在'/hc'这个路径上，用'./' 相对路径（需history模式），也可以用'/hc/'。 在'/hc'路径上，如果需要本地和线上保持一致，可以用环境做判断设置不同的publicPath值。<br>2、确定静态文件放置的位置。<br>①、如果放在public/static，不经过webpack打包， 放在public 又分使用绝对路径和相对路径。<br>②、如果放在assets， 经过webpack打包， 使用的是相对路径<br>3、路径是否是动态的，如果是动态，需要用require() 引入。 </p>
<h3 id="25-vue动态设置img"><a href="#25-vue动态设置img" class="headerlink" title="25. vue动态设置img"></a>25. vue动态设置img</h3><p><code>&lt;img :src=&quot;require(@/assets/images/xxx.png&#39;)&quot; /&gt;  </code></p>
<h3 id="26-vue-中created和mounted请求数据"><a href="#26-vue-中created和mounted请求数据" class="headerlink" title="26. vue 中created和mounted请求数据"></a>26. vue 中created和mounted请求数据</h3><p>created比mounted提前，一般在created中发送请求就可以但无法操作dom，如果涉及到需要页面加载完成之后的话就用mounted。</p>
<h3 id="27-多个后端接口"><a href="#27-多个后端接口" class="headerlink" title="27. 多个后端接口"></a>27. 多个后端接口</h3><p>devServer中把所有的服务人员的地址代理都写进去，然后动态地更改接口的baseUrl</p>
<h3 id="28-render-template-el"><a href="#28-render-template-el" class="headerlink" title="28. render>template>el"></a>28. render>template>el</h3><p>****1.****当Vue选项对象中有render渲染函数时，Vue构造函数将直接使用渲染函数渲染DOM树。</p>
<p>****2.****当选项对象中没有render渲染函数时：Vue构造函数首先通过将template模板编译生成渲染函数，然后再渲染DOM树。</p>
<p>****3.*<em><strong>而当Vue选项对象中既没有render渲染函数，也没有template模板时，会</strong></em>*通过el属性获取****挂载元素的outerHTML来作为模板，并编译生成渲染函数。</p>
<p>换言之，在进行DOM树的渲染时，render渲染函数的优先级最高，template次之且需编译成渲染函数，而挂载点el属性对应的元素若存在，则在前两者均不存在时，其outerHTML才会用于编译与渲染。</p>
<h3 id="29-template编译模板"><a href="#29-template编译模板" class="headerlink" title="29. template编译模板"></a>29. template编译模板</h3><p> vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段：</p>
<ul>
<li><strong>解析阶段</strong>： 使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。 </li>
<li><strong>优化阶段</strong>： 遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。 </li>
<li><strong>生成阶段</strong>： 将最终的AST转化为render函数字符串。</li>
</ul>
<h3 id="30-Vue首页白屏渲染"><a href="#30-Vue首页白屏渲染" class="headerlink" title="30. Vue首页白屏渲染"></a>30. Vue首页白屏渲染</h3><ul>
<li>路由懒加载：当用户打开首页时，会一次性加载所有的资源，造成首页加载很慢，降低用户体验。使用ES6的动态加载模块--<code>import()</code></li>
<li>组件懒加载：当组件复用性很高或者JS文件较大时或者用户触发时，才会加载该组件。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dialogInfo</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;dialogInfo&quot; */</span> <span class="string">&#x27;@/components/dialogInfo&#x27;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;homeView&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    dialogInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>骨架屏：在项目打包时将骨架屏的内容放到 html 文件的根节点中。</li>
<li>长列表虚拟滚动：只渲染可视区域的列表项，非可见区域的不渲染。在滚动时动态更新可视区域。<ul>
<li>原理：计算出列表的总高度，并在触发滚动事件时根据滚动长度实时更新预留缓冲区域高度，以此来从列表数据中截取。</li>
</ul>
</li>
<li>图片懒加载： 由于浏览器会自动对页面中的 img 标签的 src 属性发送请求并下载图片，可以通过 html5 自定义属性 data-xxx 先暂存 src 的值，然后在图片出现在屏幕可视区域的时候，再将 data-xxx 的值重新赋值到 img 的 src 属性 。</li>
<li>JS 异步加载：defer 是渲染完在执行，async 是加载完就执行。</li>
<li>图片转base64格式.</li>
<li>Web Woeker 优化长任务。</li>
</ul>
<h3 id="31-Vue为什么只有一个根元素"><a href="#31-Vue为什么只有一个根元素" class="headerlink" title="31. Vue为什么只有一个根元素"></a>31. Vue为什么只有一个根元素</h3><p>创建Vue实例时，只能有一个入口，也就是一个根节点，再通过此根节点来递归遍历所有节点。这也是diff算法所必需的。</p>
<h3 id="32-Vue数据发生改变页面会更新吗？如何实现异步更新的"><a href="#32-Vue数据发生改变页面会更新吗？如何实现异步更新的" class="headerlink" title="32. Vue数据发生改变页面会更新吗？如何实现异步更新的"></a>32. Vue数据发生改变页面会更新吗？如何实现异步更新的</h3><ul>
<li>Vue 不会检测到实例创建时不存在与data中的变量的改变。</li>
<li>Vue 不会检测到data 中对象属性的动态添加和删除。</li>
<li>无法通过数组索引或者赋值，也无法直接改变数组的长度。</li>
<li>异步获取接口数据，DOM 结构不发生变化。</li>
</ul>
<p>实现： Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。 </p>
<h3 id="33-Vue的render函数"><a href="#33-Vue的render函数" class="headerlink" title="33. Vue的render函数"></a>33. Vue的render函数</h3><p>VNode 虚拟DOM到真实DOM的过程，实现mount方法挂载(遍历整个DOM树，构建出真实的DOM树)，接收三个参数，节点，属性，子节点，通过判断生成一个真实的DOM元素。</p>
<h3 id="34-MVVM，MVC的理解"><a href="#34-MVVM，MVC的理解" class="headerlink" title="34. MVVM，MVC的理解"></a>34. MVVM，MVC的理解</h3><ul>
<li>Model：模型。</li>
<li>View：视图。</li>
<li>ViewModel：视图模型。MVVM的核心，主要用来处理业务逻辑。<ul>
<li>当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新 </li>
<li>当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动， 实现了数据的双向绑定</li>
</ul>
</li>
</ul>
<p>MVC的C为控制层，缺点：所有的业逻辑都在控制层中处理，不利于维护，不适合小型和中型项目。</p>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="1-React中key的作用"><a href="#1-React中key的作用" class="headerlink" title="1. React中key的作用"></a>1. React中key的作用</h2><p> keys是React用于追踪那些列表重元素被修改，呗添加或者被移除的辅助标识。</p>
<ul>
<li>React利用key来识别组件，相同的key react认为是同一个组件，这样相同的key对应组件就不会被创建。</li>
<li>有了key属性，就可以与组件建立了一种对应关系，react根据key来决定销毁重新创建组件还是更新组件。</li>
<li>key相同，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新。</li>
<li>key值不同，则react先销毁该组件，然后重新创建该组件，</li>
</ul>
<h2 id="2-React的设计思想"><a href="#2-React的设计思想" class="headerlink" title="2. React的设计思想"></a>2. React的设计思想</h2><ul>
<li>组件化。每个组件都符合开放封闭原则，封闭是针对渲染工作流来说的，指的是组件内部的状态有自身维护，只处理内部的渲染逻辑。开放是针对组件通信来说的，指的是不同组件可以通过props来进行数据交互。</li>
<li>数据驱动视图。如果要渲染界面，不应该直接操作DOM，而是通过修改数据的方式来驱动视图更新。</li>
<li>虚拟DOM。虚拟DOM是对真实DOM的印射，React通过新旧虚拟DOM对比，得到需要更新的部分。</li>
</ul>
<h2 id="3-JSX是什么，和JS的区别"><a href="#3-JSX是什么，和JS的区别" class="headerlink" title="3. JSX是什么，和JS的区别"></a>3. JSX是什么，和JS的区别</h2><p>JSX是react的语法糖，他允许在html中写JS，不能瘪浏览器直接识别，需要通过webpack babel编译工具转化为JS执行。</p>
<p>区别：</p>
<ul>
<li>JS可以被打包工具直接编译，不需要额外转换，jsx需要通过babel编译，他是 React.createElement 的语法糖。</li>
<li>jsx是js的语法扩展，允许在html中写JS；JS是原生写法，需要通过script标签引入。</li>
</ul>
<p> <strong>为什么在文件中没有使用react，也要在文件顶部import React from “react”</strong> </p>
<p>只要使用了jsx，就需要引用React，因为jsx本质上就是React.createElement</p>
<p> <strong>为什么React自定义组件首字母要大写</strong> </p>
<p>jsx通过babel转义时，调用了React.createElement函数，他接受三个参数，分别是 分别是type元素类型，props元素属性，children子元素。 </p>
<p>如果组件首字母为小写，则会被当成字符串进行传递，在创建虚拟DOM的时候，就会把它当成一个html标签。而如果是大写，就会当成一个变量进行传递，React知道他是个自定义组件。</p>
<h2 id="3-React组建为什么只能有一个根元素，为什么不能返回多个元素"><a href="#3-React组建为什么只能有一个根元素，为什么不能返回多个元素" class="headerlink" title="3. React组建为什么只能有一个根元素，为什么不能返回多个元素"></a>3. React组建为什么只能有一个根元素，为什么不能返回多个元素</h2><ul>
<li>React组件最后会被编译为render函数，函数的返回值只能是一个，如果不用单独的根节点包裹，就会并列返回多个值，这在js中是不允许的。</li>
<li>react的虚拟DOM是一个树状结构，树的根节点只能是一个，如果有多个根节点，则无法确认实在那棵树上进行更新。</li>
</ul>
<h2 id="4-React-Fragment"><a href="#4-React-Fragment" class="headerlink" title="4. React.Fragment"></a>4. React.Fragment</h2><p>可以将元素列表加到一个分组中，而且不会创建额外的节点。</p>
<h2 id="5-React的生命周期"><a href="#5-React的生命周期" class="headerlink" title="5. React的生命周期"></a>5. React的生命周期</h2><p>生名周期指的是组件实例从创建到销毁的流程，函数组件没有生命周期，只有类组件才有，因为只有class组件才会创建组件实例。</p>
<ul>
<li>挂载。 <strong>constructor</strong> 可以进行state和props的初始化 。<strong>componentDidMount</strong>第一次渲染调用，可以访问DOM，进行异步请求和定时器。</li>
<li>更新。 <strong>shouldComponentUpdate</strong> 返回一个布尔值，默认返回true，可以通过这个生命周期钩子进行性能优化，确认不需要更新组件时调用  <strong>componentDidUpdate</strong> 在组件完成更新后调用 </li>
<li>卸载。 <strong>componentWillUnmount</strong> 组件从DOM中被移除的时候调用 </li>
<li>错误捕获。 static getDerivedStateFromError 在<strong>errorBoundary</strong>中使用</li>
</ul>
<h2 id="6-React-事件机制"><a href="#6-React-事件机制" class="headerlink" title="6. React 事件机制"></a>6. React 事件机制</h2><p>React基于浏览器的事件机制实现了一套自身的事件机制，它符合W3C规范，包括事件触发，事件冒泡，事件捕获，事件 合成和事件派发等。</p>
<ul>
<li>React所有的事件绑定在container(document)上，而不是绑定在目标元素上，减少了内存开销。</li>
<li>React自身实现了一套冒泡机制，不能通过return false 阻止冒泡</li>
<li>React 通过SytheticEvent实现了时间合成。</li>
</ul>
<h2 id="7-React事件处理为什么要手动绑定this"><a href="#7-React事件处理为什么要手动绑定this" class="headerlink" title="7. React事件处理为什么要手动绑定this"></a>7. React事件处理为什么要手动绑定this</h2><p>React组件会被编译为React.createElement，在createElement中，他的this丢失了，并不是有组件实例调用的，因此需要手动绑定this.</p>
<h2 id="8-useEffect和useLayoutEffect区别"><a href="#8-useEffect和useLayoutEffect区别" class="headerlink" title="8. useEffect和useLayoutEffect区别"></a>8. useEffect和useLayoutEffect区别</h2><h2 id="9-React性能优化手段"><a href="#9-React性能优化手段" class="headerlink" title="9. React性能优化手段"></a>9. React性能优化手段</h2><ul>
<li>shouldComponentUpdate</li>
<li>memo</li>
<li>getDerviedStateFromProps</li>
<li>使用Fragment</li>
<li>v-for使用正确的key</li>
<li>拆分尽可能小的可复用组件，使用错误边界ErrorBoundary</li>
<li>使用React.lazy和React.Suspense延迟加载不需要立马使用的组件</li>
</ul>
<h2 id="10-Portal"><a href="#10-Portal" class="headerlink" title="10. Portal"></a>10. Portal</h2><p>Portal提供了让子组件渲染在除了父组件之外的DOM节点的方式，他接受两个参数，第一个元素是需要渲染的React元素，第二个是渲染的地方(DOM元素)</p>
<p><code>ReactDom.createPortal(child,container)</code></p>
<h2 id="11-React组件通信"><a href="#11-React组件通信" class="headerlink" title="11. React组件通信"></a>11. React组件通信</h2><h3 id="11-1-props"><a href="#11-1-props" class="headerlink" title="11.1 props"></a>11.1 props</h3><p>概述：父组件传递给子组件的数据，子组件不能修改该数据，在 <code>class </code>组件中通过 <code>this.props </code>的方式获取。</p>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;welcome&#x27;</span>&gt;</span>&#123;this.props.msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">    &lt;<span class="title class_">Welcome</span> msg=<span class="string">&quot;Hi Props&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>peops约束：因为从 React 15.x 开始移除了 props 约束，所以需要安装第三方模块实现</p>
<p><code>nom i --save prop-types</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;welcome&#x27;</span>&gt;</span>&#123;this.props.msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Welcome</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span></span><br><span class="line">    <span class="attr">msg</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-子传父"><a href="#11-2-子传父" class="headerlink" title="11.2 子传父"></a>11.2 子传父</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件 </span></span><br><span class="line">callback = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">    &lt;<span class="title class_">Button</span> callback=&#123;callback&#125;&gt;</span><br><span class="line">    &lt;/<span class="title class_">Button</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件 </span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">callback</span>(<span class="string">&#x27;传递给父组件数据&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="11-3-Context"><a href="#11-3-Context" class="headerlink" title="11.3 Context"></a>11.3 Context</h3><p>Context提供了一种跨层级组建数据传递的方法，他解决了组件嵌套造成数据来源不清晰，多余的变量定义等问题。</p>
<p>使用：</p>
<ol>
<li>新建 <code>context</code>文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>([]) <span class="comment">// 创建一个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyContext</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新建<code>Provider</code> 组件</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyContext</span> <span class="keyword">from</span> <span class="string">&#x27;./MyContext&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Provider</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">list</span>: [],</span><br><span class="line">  &#125;</span><br><span class="line">  changeMsg = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      msg,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  addList = <span class="function">(<span class="params">todo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">list</span>: [...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span>, todo],</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">msg</span>,</span><br><span class="line">      <span class="attr">list</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span>,</span><br><span class="line">      <span class="attr">changeMsg</span>: <span class="variable language_">this</span>.<span class="property">changeMsg</span>,</span><br><span class="line">      <span class="attr">addList</span>: <span class="variable language_">this</span>.<span class="property">addList</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>class 组件使用 value</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;value.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>函数组件使用</li>
</ol>
<p>概述： 允许在函数组件中使用 context 对象，在 context 值发生改变时重新渲染。</p>
<p>问题：context 的值发生改变，无论子组件是否引用 value， 都会导致 子组件重新渲染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useContext&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>); <span class="comment">// 需要接受context作为参数</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;context.msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">     )</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-4-UseReducer"><a href="#11-4-UseReducer" class="headerlink" title="11.4 UseReducer"></a>11.4 UseReducer</h3><p>概述： useReducer 是 useState 的替代方案，能够解决 useState 状态更新逻辑散落在 UI 中，不能独立复用，不方便测试。</p>
<p>使用：</p>
<ol>
<li>新建<code>FnProvider</code>组件</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyContext</span> <span class="keyword">from</span> <span class="string">&#x27;./MyContext&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todoReducer <span class="keyword">from</span> <span class="string">&#x27;./todoReducer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">FnProvider</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [msg, changeMsg] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment">//   const [todoList, setTodoList] = useState([])</span></span><br><span class="line">  <span class="keyword">const</span> [todoList, dispatch] = <span class="title function_">useReducer</span>(todoReducer, [])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>FnProvider<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyContext.Provider</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">msg</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">changeMsg</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">todoList</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">dispatch</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新建<code>reducer.js</code>文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">todoReducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [...state, action.<span class="property">todo</span>]</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DEL&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">id</span> !== action.<span class="property">id</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;EDIT&#x27;</span>:</span><br><span class="line">      <span class="keyword">const</span> index = state.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">id</span> === action.<span class="property">payload</span>.<span class="property">id</span>) <span class="comment">// 返回下标</span></span><br><span class="line">      <span class="keyword">const</span> newTodoList = [...state]</span><br><span class="line">      newTodoList.<span class="title function_">splice</span>(index, <span class="number">1</span>, action.<span class="property">payload</span>.<span class="property">todo</span>)</span><br><span class="line">      <span class="keyword">return</span> newTodoList</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">FnProvider</span> <span class="keyword">from</span> <span class="string">&#x27;./store/FnProvider&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">FnProvider</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line">  &lt;/<span class="title class_">FnProvider</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>)</span><br><span class="line"></span><br><span class="line">onClick=&#123;<span class="function">() =&gt;</span></span><br><span class="line">          context.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;DEL&#x27;</span>,</span><br><span class="line">            <span class="attr">id</span>: item.<span class="property">id</span>,</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-5-Redux"><a href="#11-5-Redux" class="headerlink" title="11.5 Redux"></a>11.5 Redux</h3><p>Redux是一个状态管理库，应用于跨层级组建数据共享与通信，一些需要持久化的全局数据，比如用户登录信息。</p>
<p>新项目：</p>
<p><code>npx create-react-app 项目名 --template redux</code></p>
<p><code>npx create-react-app 项目名 --template redux-typescript</code></p>
<p>老项目：</p>
<p><code>npm i redux react-redux</code></p>
<h5 id="11-5-1-项目引入"><a href="#11-5-1-项目引入" class="headerlink" title="11.5.1 项目引入"></a>11.5.1 项目引入</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="title function_">reportWebVitals</span>();</span><br></pre></td></tr></table></figure>

<h5 id="11-5-2-store-创建"><a href="#11-5-2-store-创建" class="headerlink" title="11.5.2 store 创建"></a>11.5.2 store 创建</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer/reducer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todoReduce <span class="keyword">from</span> <span class="string">&#x27;./reducer/todoReducer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mainReducer = <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: reducer,</span><br><span class="line">  <span class="attr">todo</span>: todoReduce,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(mainReducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测 state 的变化</span></span><br><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据发生改变&#x27;</span>, store.<span class="title function_">getState</span>())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="11-5-3-reducer"><a href="#11-5-3-reducer" class="headerlink" title="11.5.3 reducer"></a>11.5.3 reducer</h5><p>概述：是一个纯函数，会根据不同的 action 对象返回一个新的 state</p>
<p>纯函数：</p>
<ul>
<li>不修改传入的参数</li>
<li>不执行有副作用的操作，比如API，计时器等等</li>
<li>不调用非纯函数，如<code>new Date()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initData = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">    <span class="attr">flag</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;练习篮球一年半&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addActionType = <span class="string">&#x27;ADD&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addTodo</span> = (<span class="params">payload</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: addActionType,</span><br><span class="line">    payload,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> editActionType = <span class="string">&#x27;EDIT&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">editTodo</span> = (<span class="params">payload</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: editActionType,</span><br><span class="line">    payload,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DelType</span> = <span class="string">&#x27;DEL&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">actionDel</span> = (<span class="params">payload</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="title class_">DelType</span>,</span><br><span class="line">  payload,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">todoReduce</span>(<span class="params">state = initData, action</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, payload &#125; = action</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">addActionType</span>:</span><br><span class="line">      <span class="keyword">return</span> [...state, payload]</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">DelType</span>:</span><br><span class="line">      <span class="keyword">return</span> state.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">id</span> !== payload.<span class="property">id</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">editActionType</span>:</span><br><span class="line">      <span class="keyword">const</span> index = state.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">id</span> === payload.<span class="property">id</span>) <span class="comment">// 返回下标</span></span><br><span class="line">      <span class="keyword">const</span> newTodoList = [...state]</span><br><span class="line">      newTodoList.<span class="title function_">splice</span>(index, <span class="number">1</span>, payload)</span><br><span class="line">      <span class="keyword">return</span> newTodoList</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="11-5-4-combineReducers"><a href="#11-5-4-combineReducers" class="headerlink" title="11.5.4 combineReducers"></a>11.5.4 combineReducers</h5><p>概述：用于将多个 reducer 合并为一个 reducer。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mainReducer = <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">    home,</span><br><span class="line">    user,</span><br><span class="line">    todo</span><br><span class="line">&#125;)</span><br><span class="line">store = <span class="title function_">createStore</span>(mainReducer)</span><br></pre></td></tr></table></figure>

<h5 id="11-5-5-useSelector"><a href="#11-5-5-useSelector" class="headerlink" title="11.5.5 useSelector"></a>11.5.5 useSelector</h5><p>概述：用于组件中获取 state 的hook</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useSelector&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> const App =() =&gt; &#123;</span></span><br><span class="line"><span class="string">    const todoList = useSelector((state) =&gt; state.todo)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h5 id="11-5-6-useDispatch"><a href="#11-5-6-useDispatch" class="headerlink" title="11.5.6 useDispatch"></a>11.5.6 useDispatch</h5><p>概述：返回 dispatch 函数的引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useDispatch&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const App =() =&gt; &#123;</span></span><br><span class="line"><span class="string">    const dispatch = useDispatch()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    const onSubmitTodo = () =&gt; &#123;</span></span><br><span class="line"><span class="string">    dispatch(</span></span><br><span class="line"><span class="string">      addTodo(&#123;</span></span><br><span class="line"><span class="string">        text,</span></span><br><span class="line"><span class="string">        id: Date.now(),</span></span><br><span class="line"><span class="string">        flag: false,</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">    setText(&#x27;</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="11-5-7-redux-thunk"><a href="#11-5-7-redux-thunk" class="headerlink" title="11.5.7 redux-thunk"></a>11.5.7 redux-thunk</h5><p>概述： 因为在 reducer 中只能同步操作，那么要想异步处理 redux 就只能在组件中先进行异步操作，然后成功后再 dispatch。但是会让redux 的逻辑散落在UI中，不易于后期管理。</p>
<p>接用该插件可以实现 dispatch 一个函数，然后在这个函数中处理异步。</p>
<p><code>index.js</code> 文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> logger <span class="keyword">from</span> <span class="string">&#x27;redux-logger&#x27;</span></span><br><span class="line"><span class="keyword">import</span> mainReducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middleWares = [</span><br><span class="line">  <span class="comment">// 三方模块通过该中间件注册</span></span><br><span class="line">  thunkMiddleware,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">  middleWares.<span class="title function_">push</span>(logger)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redux DevTools 配置</span></span><br><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="variable language_">window</span>.<span class="property">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span> || compose</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  mainReducer,</span><br><span class="line">  <span class="title function_">composeEnhancers</span>(<span class="title function_">applyMiddleware</span>(...middleWares))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测redux 的状态变化</span></span><br><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据发生改变&#x27;</span>, store.<span class="title function_">getState</span>())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>userAction.js</code>文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">LOGIN</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../actionTypes/userActionType&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; loginApi &#125; <span class="keyword">from</span> <span class="string">&#x27;../../http/Api/user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步 类似于 Vuex-mutation</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">loginAction</span> = (<span class="params">payload</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="variable constant_">LOGIN</span>,</span><br><span class="line">  payload,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">loginActionAsync</span> = (<span class="params">payload</span>) =&gt; <span class="function">(<span class="params">dispatch</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">loginApi</span>(payload).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="string">&#x27;200&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">dispatch</span>(<span class="title function_">loginAction</span>(res.<span class="property">data</span>.<span class="property">data</span>))</span><br><span class="line">        <span class="title function_">resolve</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登陆失败&#x27;</span>)</span><br><span class="line">        <span class="title function_">reject</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>userReducer.js</code>文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">LOGIN</span>, <span class="variable constant_">LOGOUT</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../actionTypes/userActionType&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">INIT_STATE</span> = &#123;</span><br><span class="line">  <span class="attr">userId</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">username</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">authList</span>: [],</span><br><span class="line">  <span class="attr">token</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">userReducer</span>(<span class="params">state = INIT_STATE, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">LOGIN</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        ...action.<span class="property">payload</span>,</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="attr">LOGOUT</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">userId</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">username</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">authList</span>: [],</span><br><span class="line">        <span class="attr">token</span>: <span class="literal">null</span>,</span><br><span class="line">      &#125;                      </span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>reducer/index.js</code>文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> userReducer <span class="keyword">from</span> <span class="string">&#x27;./userReducer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">  <span class="attr">user</span>: userReducer,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; loginAction, loginActionAsync &#125; <span class="keyword">from</span> <span class="string">&#x27;../../store/actions/userAction&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Login</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>()</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>()</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onFinish</span> = <span class="keyword">async</span> (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    <span class="title function_">dispatch</span>(<span class="title function_">loginActionAsync</span>(value)).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">navigate</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-React-和-Vue的区别"><a href="#12-React-和-Vue的区别" class="headerlink" title="12. React 和 Vue的区别"></a>12. React 和 Vue的区别</h2><p>相同点：</p>
<ul>
<li>数据驱动视图</li>
<li>组件化思想</li>
<li>都是用虚拟Dom</li>
</ul>
<p>不同点：</p>
<ul>
<li>核心思想不通：<ul>
<li>Vue为渐进式框架，门槛较低，进行数据劫持或者代理</li>
<li>React函数式编程，数据不可变以及单向数据流</li>
</ul>
</li>
<li>组件写法差异：<ul>
<li>Vue单文件组建格式，即html,css,js写在同一个文件</li>
<li>React为html和css都写进js中</li>
</ul>
</li>
<li>diff算法不同：<ul>
<li>react 首先对新集合进行遍历，通过唯一key值来判断新旧集合中是否存在相同的节点，如果没有的话就创建，如果有的话就会将节点在新集合中的位置和老集合中的位置进行比较，如果不同，则进行移动操作，否则就不操作。如果在遍历的过程中，发现在新集合中没有，就会进行删除操作。</li>
<li>Vue新旧集合各有头尾的变量，他们的2各变量相互比较，一共有四种比较方式，如果四种都没匹配，则会匹配key值，借助key值找到可复用的节点，在进行相关操作。</li>
</ul>
</li>
<li>响应式原理不同：</li>
<li><ul>
<li>Vue依赖收集，自动依赖，数据可变。递归监听data中的所有属性，直接修改，当数据改变时，自动找到引用组件重新渲染。</li>
<li>React基于状态手动优化，数据不可变，需要setState驱动新的state替换老的state。当数据改变时，以组件为根目录，默认全部重新渲染，所以React中会需要shouldComponentUpdate这个生命周期函数来进行控制。</li>
</ul>
</li>
</ul>
<h2 id="13-SetState是同步还是异步的"><a href="#13-SetState是同步还是异步的" class="headerlink" title="13. SetState是同步还是异步的"></a>13. SetState是同步还是异步的</h2><p><code>setState </code>是一个异步方法，但是在<code>setTimeout</code>/<code>setInterval</code>等定时器里逃脱了<code>React</code>对他的掌控，变成了同步方法。</p>
<p>实现机制：类似于<code>Vue</code>的<code>$nextTick</code>和浏览器的时间循环机制，每个<code>setState</code>都会被<code>React</code>加入到任务队列当中，多次对同一个state使用setState只会返回最后一次的结果，因为他不是立刻就更新，而是先放在任务队列中，等时机成熟在执行批量更新。而在<code>React</code>18以后，使用了createRoot api后，所有setState都是异步批量执行。</p>
<h2 id="14-React渲染流程"><a href="#14-React渲染流程" class="headerlink" title="14. React渲染流程"></a>14. React渲染流程</h2><p>React用JSX描述页面，JSX经过babel编译为render function，执行后产生VDOM，VDOM并不会直接渲染，而是会先转换为fiber，在进行渲染。VDOM转换为fiber的过程叫reconcile，转换过程会创建DOM，全部转换完成后会一次性commit到DOM，这个过程不是一次性的，而是可打断的。</p>
<h2 id="15-React常用hooks"><a href="#15-React常用hooks" class="headerlink" title="15. React常用hooks"></a>15. React常用hooks</h2><h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><ol>
<li><p>创建登录组件</p>
<ul>
<li><p>在component文件夹中创建一个登录组件Login.vue</p>
</li>
<li><p>在路由文件中导入登录组件,并添加路由规则</p>
</li>
<li><pre><code class="js">import Login from &#39;../components/Login.vue&#39; const routes = [ 
//重定向路由（当用户访问/时，会自动定向到登录路由）
&#123; path: &#39;/&#39;, redirect: &#39;/login&#39; &#125;, //登录组件路由 
&#123; path: &#39;/login&#39;, component: Login &#125; 
]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 登录页面基本布局</span><br><span class="line"></span><br><span class="line">   - 因为在安装Element插件时配置的是按需导入，因此需要在plugins文件夹中的element.js文件中导入需要用到的组件，并注册为全局可用</span><br><span class="line"></span><br><span class="line">3. 登录表单数据绑定</span><br><span class="line"></span><br><span class="line">   - 根据在Element官网我们所选择的表单组件中绑定数据的方式去绑定我们需要的数据 给密码框添加`type=&#x27;password&#x27;`属性，将密码隐藏</span><br><span class="line"></span><br><span class="line">4. 登录表单数据验证</span><br><span class="line"></span><br><span class="line">   - 根据在Element官网中Form 组件提供了表单验证的功能，只需给表单绑定 rules 属性，并传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即</span><br><span class="line"></span><br><span class="line">5. 点击重置按钮实现表单重置</span><br><span class="line"></span><br><span class="line">   - 首先通过`ref`给表单添加一个引用对象，之后只要获取到这个引用对象（可以任意命名，只要合法），就可以获取到这个表单的实例对象</span><br><span class="line">   - 给重置按钮添加单机事件，并命名事件处理函数</span><br><span class="line">   - 使用Element官网在Form表单组件中提供的`resetFields`方法（对整个表单进行重置，将所有字段值重置为初始值并移除校验结果）表单实例方法就可以重置表单</span><br><span class="line"></span><br><span class="line">6. 点击登录，对表单数据进行预验证（在发送请求之前）</span><br><span class="line"></span><br><span class="line">   - Form表单组件中提供的`validate`（对整个表单进行校验的方法，参数为一个回调函数。该回调函数会在校验结束后被调用，并传入两个参数：是否校验成功和未通过校验的字段。若不传入回调函数，则会返回一个 promise）表单实例方法就可以对表单进行预验证</span><br><span class="line"></span><br><span class="line">7. 发送登录请求（通过预验证后）</span><br><span class="line"></span><br><span class="line">   - 在入口文件导入`axios`，将其挂载到Vue的原型对象上，并配置请求根路径</span><br><span class="line">   - 在登录事件处理函数中发送请求（异步），使用async/await关键字处理异步代码，返回值是一个对象，其中只有data属性中包含的是有用的服务器返回数据，所以将其解构赋值到一个变量</span><br><span class="line"></span><br><span class="line">8. 告诉用户登录结果</span><br><span class="line"></span><br><span class="line">   - Message 消息提示的组件，在element.js文件中导入需要用到的组件，该组件需要进行全局挂载，而不是全局注册</span><br><span class="line">   - 根据接收到的登录请求返回的状态码来提示用户是否登录成功</span><br><span class="line"></span><br><span class="line">9. 登录成功之后的行为</span><br><span class="line"></span><br><span class="line">   - 将登录成功后，服务器返回的token保存到客户端的sessionStorge中，保持登录状态（sessionStorge和localStorge保存期限不同，sessionStorge在窗口关闭后会删除保存的数据，localStorge没有保存期限）；所有API接口除了登录接口外，都需要登录之后才能访问</span><br><span class="line">   - 通过编程式导航跳转到后台主页，路由地址是/home</span><br><span class="line"></span><br><span class="line">10. 路由导航守卫</span><br><span class="line"></span><br><span class="line">    - 在路由文件中添加导航守卫：如果用户没有登录，用户可以通过直接输入URL地址访问页面，这是不合理的，因此需要重新导航到登录页面</span><br><span class="line"></span><br><span class="line">    - ```js</span><br><span class="line">      // 挂载路由导航守卫</span><br><span class="line">      router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">        // to 代表将要访问的路径</span><br><span class="line">        // from 代表从那个路径跳转而来</span><br><span class="line">        // next 是一个函数，表示是否放行</span><br><span class="line">        // next()  放行   next(&#x27;/login&#x27;)  强制跳转</span><br><span class="line">        if (to.path === &#x27;/login&#x27;) return next()</span><br><span class="line">        // 获取 token </span><br><span class="line">        const tokenStr = window.sessionStorage.getItem(&#x27;token&#x27;)</span><br><span class="line">        if (!tokenStr) return next(&#x27;/login&#x27;)</span><br><span class="line">        next()</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>实现退出功能</p>
<ul>
<li><p>在Home组件中暂时添加一个退出按钮</p>
</li>
<li><p>给按钮绑定单机事件，并命名事件处理函数</p>
</li>
<li><p>定义事件处理函数，基于token实现退出功能只需销毁本地token即可</p>
</li>
<li><pre><code class="js">logout() &#123;
      window.sessionStorage.clear();
      this.$router.push(&quot;/login&quot;);
    &#125;,
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="1-登录验证"><a href="#1-登录验证" class="headerlink" title="1. 登录验证"></a>1. 登录验证</h3><h3 id="2-项目的优化"><a href="#2-项目的优化" class="headerlink" title="2. 项目的优化"></a>2. 项目的优化</h3><ul>
<li>在可视化的UI面板中查看控制台和分析面板，看到项目中所存在的问题，资源文件和依赖项文件等文件大小是否需要优化</li>
<li>Element-UI组件按需加载</li>
<li>第三方库启用CDN,可以通过 webpack 的 externals 节点，来配置并加载外部的 CDN 资源。</li>
<li>路由懒加载，将路由相关的组件，不再直接导入了，而是改写成异步组件的写法，只有当函数被调用的时候，才去加载对应的组件内容。路由懒加载就是只加载你当前点击的那个模块</li>
<li>开启 gzip 配置，减小文件体积，使传输速度更快。<ul>
<li>安装相应包<code>npm install compression -S</code></li>
<li>导入包<code>const compression = require(&#39;compression&#39;);</code></li>
<li>启用中间件<code>app.use(compression());</code></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">野菜</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2021/01/01/face/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2021/01/01/face/')">面试题</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2021/01/01/face/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=面试题&amp;url=http://example.com/2021/01/01/face/&amp;pic=https://api.gumengya.com/Api/FjImg?format=image&amp;_t=4" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">野菜</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试题<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/bg.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/01/01/compute/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://api.gumengya.com/Api/FjImg?format=image&amp;_t=3" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机基础笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML"><span class="toc-number">1.</span> <span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-html5%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.1.</span> <span class="toc-text">1.  html5有什么优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3HTML%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">1.0.2.</span> <span class="toc-text">2. 如何理解HTML语义化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-meta%E6%A0%87%E7%AD%BE"><span class="toc-number">1.0.3.</span> <span class="toc-text">3. meta标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-src-%E5%92%8C-href-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.4.</span> <span class="toc-text">4. src 和 href 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSS"><span class="toc-number">2.</span> <span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-css3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">2.0.1.</span> <span class="toc-text">0. css3有什么优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.0.2.</span> <span class="toc-text">1. CSS选择器及优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-position-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.3.</span> <span class="toc-text">2. position 属性的值有哪些及其区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-box-sizing%E5%B1%9E%E6%80%A7"><span class="toc-number">2.0.4.</span> <span class="toc-text">3. box-sizing属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-CSS-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.5.</span> <span class="toc-text">4. CSS 盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-BFC%EF%BC%88%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%89%E5%92%8CIFC-%E8%A1%8C%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B"><span class="toc-number">2.0.6.</span> <span class="toc-text">5. BFC（块级格式上下文）和IFC(行级格式化上下)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">2.0.7.</span> <span class="toc-text">6. 水平垂直居中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80"><span class="toc-number">2.0.7.1.</span> <span class="toc-text">自适应两栏布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80"><span class="toc-number">2.0.7.2.</span> <span class="toc-text">三栏布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E7%AC%A6%E5%8F%B7"><span class="toc-number">2.0.8.</span> <span class="toc-text">7. 用CSS实现三角符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88%E6%9F%A5%EF%BC%89"><span class="toc-number">2.0.9.</span> <span class="toc-text">8. 常见的布局类型（查）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%B5%AE%E5%8A%A8%EF%BC%88%E6%9F%A5%EF%BC%89"><span class="toc-number">2.0.10.</span> <span class="toc-text">9. 浮动（查）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0"><span class="toc-number">2.0.11.</span> <span class="toc-text">10. 常见的行内元素和块级元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-px-em-rem-vw-vh-rpx%E7%AD%89%E5%8D%95%E4%BD%8D%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.0.12.</span> <span class="toc-text">11. px,em,rem,vw,vh,rpx等单位的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AFDOM%E4%BA%8B%E4%BB%B6%E6%B5%81%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98-%E6%9F%A5"><span class="toc-number">2.0.13.</span> <span class="toc-text">12. 什么是DOM事件流？什么是事件委托(查)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E6%8D%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%88%E6%9F%A5%EF%BC%89"><span class="toc-number">2.0.14.</span> <span class="toc-text">13. 事件冒泡和事件捕捉有什么区别（查）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-link%E5%92%8C-import"><span class="toc-number">2.0.15.</span> <span class="toc-text">14. link和@import</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-number">2.0.16.</span> <span class="toc-text">15. 响应式布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%85%83%E7%B4%A0%E4%B8%8D%E5%8F%AF%E8%A7%81"><span class="toc-number">2.0.17.</span> <span class="toc-text">16. 元素不可见</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-css%E5%8A%A8%E7%94%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">2.0.18.</span> <span class="toc-text">17. css动画属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#transform-translate-%E5%8F%82%E6%95%B01%EF%BC%8C%E5%8F%82%E6%95%B02-%E2%80%94%E2%80%94%E2%80%94%E4%BD%8D%E7%A7%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">2.0.18.1.</span> <span class="toc-text">transform:translate(参数1，参数2)———位移属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transform-scale-%E2%80%94%E2%80%94%E2%80%94-2D%E7%BC%A9%E6%94%BE"><span class="toc-number">2.0.18.2.</span> <span class="toc-text">transform:scale()———-2D缩放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transform-rotate-%E2%80%94%E2%80%94%E2%80%942D%E6%97%8B%E8%BD%AC"><span class="toc-number">2.0.18.3.</span> <span class="toc-text">transform:rotate()———2D旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation%E5%B1%9E%E6%80%A7"><span class="toc-number">2.0.18.4.</span> <span class="toc-text">animation属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-name"><span class="toc-number">2.0.18.5.</span> <span class="toc-text">animation-name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-duration"><span class="toc-number">2.0.18.6.</span> <span class="toc-text">animation-duration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-timing-function"><span class="toc-number">2.0.18.7.</span> <span class="toc-text">animation-timing-function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-iteration-count"><span class="toc-number">2.0.18.8.</span> <span class="toc-text">animation-iteration-count</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS"><span class="toc-number">3.</span> <span class="toc-text">JS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-Object%E5%B8%B8%E7%94%A8%E7%9A%84API"><span class="toc-number">3.0.1.</span> <span class="toc-text">0. Object常用的API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.0.2.</span> <span class="toc-text">1. 基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B"><span class="toc-number">3.0.3.</span> <span class="toc-text">2. 数据类型检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">3.0.4.</span> <span class="toc-text">数据类型转换：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">3.0.5.</span> <span class="toc-text">4. 作用域和作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-number">3.0.6.</span> <span class="toc-text">5. 什么是闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-this%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-number">3.0.7.</span> <span class="toc-text">6. this的指向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-new-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.0.8.</span> <span class="toc-text">7. new 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.9.</span> <span class="toc-text">9. &#x3D;&#x3D; 和&#x3D;&#x3D;&#x3D;的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-NaN-NaN%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88"><span class="toc-number">3.0.10.</span> <span class="toc-text">10. NaN &#x3D;&#x3D;&#x3D; NaN返回什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%89%8B%E5%86%99call%E3%80%81apply%E3%80%81bind%EF%BC%88%E6%9F%A5%EF%BC%89"><span class="toc-number">3.0.11.</span> <span class="toc-text">11. 手写call、apply、bind（查）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%89%A7%E8%A1%8C%E6%A0%88%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">3.0.12.</span> <span class="toc-text">12. 执行栈和执行上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">3.0.13.</span> <span class="toc-text">13. 原型，原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-JS-%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">3.0.14.</span> <span class="toc-text">14. JS 中的常用的继承方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">3.0.15.</span> <span class="toc-text">15. 内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">3.0.16.</span> <span class="toc-text">16. 垃圾回收机制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.0.17.</span> <span class="toc-text">17. 深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-js%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.0.18.</span> <span class="toc-text">18. js是单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-promise"><span class="toc-number">3.0.19.</span> <span class="toc-text">19. promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-async%E5%92%8Cawait"><span class="toc-number">3.0.20.</span> <span class="toc-text">20. async和await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.0.21.</span> <span class="toc-text">21. 宏任务和微任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-event-loop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.0.22.</span> <span class="toc-text">22. js执行机制(event loop 事件循环)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">3.0.23.</span> <span class="toc-text">24. 防抖和节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%EF%BC%88%E6%9F%A5%EF%BC%89"><span class="toc-number">3.0.24.</span> <span class="toc-text">26. 常用的数组方法（查）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">3.0.24.1.</span> <span class="toc-text">1. 数组排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">3.0.24.2.</span> <span class="toc-text">2. 数组最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">3.0.24.2.1.</span> <span class="toc-text">1. 冒泡排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">3.0.24.3.</span> <span class="toc-text">3. 数组去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">3.0.24.4.</span> <span class="toc-text">4. 反转数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">3.0.24.5.</span> <span class="toc-text">5. 遍历数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-for-of"><span class="toc-number">3.0.24.5.1.</span> <span class="toc-text">1. for of</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-forEach"><span class="toc-number">3.0.24.5.2.</span> <span class="toc-text">2. forEach</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-some"><span class="toc-number">3.0.24.5.3.</span> <span class="toc-text">3. some</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-every"><span class="toc-number">3.0.24.5.4.</span> <span class="toc-text">4. every</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-map"><span class="toc-number">3.0.24.5.5.</span> <span class="toc-text">5. map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-filter"><span class="toc-number">3.0.24.5.6.</span> <span class="toc-text">6. filter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-find"><span class="toc-number">3.0.24.5.7.</span> <span class="toc-text">7. find()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-bom%E5%92%8Cdom%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.25.</span> <span class="toc-text">28. bom和dom的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-JS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.0.26.</span> <span class="toc-text">29. JS性能优化的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-defer-%E5%92%8C-async"><span class="toc-number">3.0.27.</span> <span class="toc-text">30. defer 和 async</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/04/js%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" title="js的使用方法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/bg.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js的使用方法"/></a><div class="content"><a class="title" href="/2025/11/04/js%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" title="js的使用方法">js的使用方法</a><time datetime="2025-11-04T10:19:31.194Z" title="发表于 2025-11-04 18:19:31">2025-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/04/%E5%AD%A6%E4%B9%A0ts/" title="ts学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/bg.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ts学习"/></a><div class="content"><a class="title" href="/2025/11/04/%E5%AD%A6%E4%B9%A0ts/" title="ts学习">ts学习</a><time datetime="2025-11-04T10:02:22.066Z" title="发表于 2025-11-04 18:02:22">2025-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/02/jsproject/" title="js工具"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/bg.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js工具"/></a><div class="content"><a class="title" href="/2025/11/02/jsproject/" title="js工具">js工具</a><time datetime="2025-11-01T16:00:00.000Z" title="发表于 2025-11-02 00:00:00">2025-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/29/mysql/" title="MySQL使用手册"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/bg.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL使用手册"/></a><div class="content"><a class="title" href="/2025/10/29/mysql/" title="MySQL使用手册">MySQL使用手册</a><time datetime="2025-10-28T16:00:00.000Z" title="发表于 2025-10-29 00:00:00">2025-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/26/Nginx/" title="Nginx配置"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/bg.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx配置"/></a><div class="content"><a class="title" href="/2025/10/26/Nginx/" title="Nginx配置">Nginx配置</a><time datetime="2025-10-25T16:00:00.000Z" title="发表于 2025-10-26 00:00:00">2025-10-26</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="野菜" target="_blank">野菜</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">12</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://wjt03.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AJAX/" style="font-size: 0.88rem;">AJAX<sup>1</sup></a><a href="/tags/Axios/" style="font-size: 0.88rem;">Axios<sup>1</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>1</sup></a><a href="/tags/Node-js/" style="font-size: 0.88rem;">Node.js<sup>1</sup></a><a href="/tags/React/" style="font-size: 0.88rem;">React<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 0.88rem;">TypeScript<sup>1</sup></a><a href="/tags/Vue/" style="font-size: 0.88rem;">Vue<sup>3</sup></a><a href="/tags/Vue3/" style="font-size: 0.88rem;">Vue3<sup>1</sup></a><a href="/tags/canvas/" style="font-size: 0.88rem;">canvas<sup>1</sup></a><a href="/tags/host/" style="font-size: 0.88rem;">host<sup>1</sup></a><a href="/tags/js/" style="font-size: 0.88rem;">js<sup>3</sup></a><a href="/tags/this/" style="font-size: 0.88rem;">this<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.88rem;">前端<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem;">博客<sup>1</sup></a><a href="/tags/%E6%8C%87%E4%BB%A4/" style="font-size: 0.88rem;">指令<sup>1</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem;">教程<sup>1</sup></a><a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 0.88rem;">框架<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">笔记<sup>3</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">系统<sup>4</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 0.88rem;">编程<sup>12</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 0.88rem;">面试题<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" style="font-size: 0.88rem;">项目总结<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="14379744963" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 野菜 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2021 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>